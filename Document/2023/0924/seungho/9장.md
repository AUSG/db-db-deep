# 9장

# 백업과 복구

# Durability

ACID의 D에 해당하는 Durability (지속성)은 일련의 데이터 동작(트랜지션 동작)을 완료(COMMIT)하고, 완료 통지를 사용자가 받은 시점에서는 그 동작이 ‘영속화’되어 결과를 잃어버리지 않는 것을 나타낸다.

→ DB server나 OS의 비정상적 종료 시에도 해당 속성을 유지해야한다.

## DBMS에서 데이터를 보존하는 방법

1. 하드디스크에 저장
    - 데이터베이스의 쓰기는 기억장치의 임의 장소에 무작위로 엑세스한 후 쓰기 때문에, 동기화를 통해 쓰는 방법은 성능 면에서 매우 비효율적이다.
2. 로그 선행 쓰기 (Write Ahead Log, WAL)
    - 데이터베이스의 데이터 파일 변경을 직접 수행하지 않고, 로그로 변경 내용을 기술한 로그 레코드를 써서 동기화.
    - in MySQL, called InnoDB Log
        1. 디스크에 연속해서 쓰기 때문에, 무작위 엑세스보다 성능 좋다.
        2. 디스크에 쓰는 용량과 횟수를 줄일 수 있다.
        3. **데이터베이스 버퍼**를 이용해 데이터베이스의 데이터 파일로의 변경을 효율성 높게 수행.

### 데이터베이스 버퍼

- 커밋 시에는 WAL에 변경 내용을 쓰기 때무에, 데이터 파일의 변경 내용은 트랜잭션이 커밋되면서 동시에 동기화할 필요가 없다.
- 또한 트랜잭션 각각에 버퍼를 취하는 방법도 로그와 데이터 파일 간 일관성 유지가 어렵다.

> 따라서, 데이터베이스 버퍼를 통해 데이터  파일로의 입력을 일원화.
> 

### 크래시 복구

> 크래시 (Crash) : 비정상적으로 DB 등의 시스템이 종료될 경우
> 
1. WAL : 마지막으로 커밋된 트랜잭션의 갱신 정보를 가진다.
2. 데이터베이스 버퍼 : 크래시로 내용이 전부 소실 (버퍼가 메모리, 즉 RAM에 있기 때문)
3. 최후 체크포인트까지의 갱신 정보를 가진다.

만약 크래시가 발생했다면, WAL의 체크포인트 이후 갱신 정보를 사용해 데이터베이스를 크래시 직전까지의 최신 상태로 수정해놓는다. 이 과정을 ‘롤 포워드 (ROLL-Forward)라고 한다.

하지만, 논리적인 파괴 (쿼리 잘못보내서 테이블 없앤다거나…)나 물리적인 파손(디스크 장치가 고장났을 때)에는 방법이 없다. 따라서 주기적으로 백업을 해놓는게 최고의 예방책이다.

## 백업과 복구

### PITR (Point-In-Time Recovery)

임의의 시점에서의 데이터 변경을 포함한 복원을 뜻한다. MySQL에서는 PITR에 사용되는 로그를 ‘바이너리 로그’라고 부른다.

### 아카이브 지정이란?

크래시 복구용으로 쓰이는 WAL은 체크포인트 이전의 로그들은 불필요하기 때문에, 보존할 필요가 없지만, PITR용 로그는 특정 시점으로 돌아가는 로그들이 필요하기 때문에 체크포인트 이전의 로그들도 보존할 필요가 있다. 이런 특징을 지정할 수 있는 것이 아카이브 지정이다.

## 백업의 3가지 관점

### 핫 백업 vs 콜드 백업

- 핫 백업 (=Online Backup)
    - 백업 대상의 데이터베이스를 정지하지 않고 가동한 채로 백업 데이터를 얻는다.
    - MySQL에서는 트랜잭션의 구조를 이용하거나, 특수한 로그를 지정하거나, OS나 하드웨어의 ‘스냅샷’을 이욯해 해당 시점의 스냅샷을 백업 데이터로 취득하는 방식으로 백업한다.
    - `mysqldump` 을 이용할 수도 있다.
    - ‘DataBase 기능’으로 백업하는 방식 → 가용성 GOOD
        
        [[mysql] DB 백업(dump)을 위한 mysqldump사용법](https://devpouch.tistory.com/114)
        
- 콜드 백업 (= Offline Backup)
    - 백업 대상의 데이터베이스를 정지한 후 백업 데이터를 얻는다.
    - MySQL에서는 MySQL 서버를 셧다운한 후, 데이터 디렉터리에 있는 디렉터리와 파일을 전부 OS 명령으로 복사한다.
    - ‘OS 기능’으로 백업하는 방식 → 성능 GOOD

| 백업 종류 | Hot Backup | Cold Backup |
| --- | --- | --- |
| 수행 속도 | 중 | 상 |
| 저장 단위 | 데이터 파일 | 데이터 파일 |
| 부분 복구 | 테이블스페이스 | 테이블스페이스 |
| 증분 백업 | X | X |

### 논리 백업 vs 물리 백업

- 논리 백업
    - SQL 기반의 텍스트 형식으로 백업 데이터 기록
    - 주로 Open-Source DB에서 사용
    - 장점
        - 편집할 수 있다.
        - 이식성이 우수하다. 텍스트 변경으로 동일한 DBMS의 다른 버전이나 다른 DBMS에 복원 가능하다.
    - 단점
        - 물리 백업보다 크기가 크다. 또한 바이너리 - 텍스트 상호교환에 들어가기 위한 동작속도가 느리다.
- 물리 백업
    - 데이터 영역을 그대로 덤프하는 이미지로 바이너리 형식으로 기록.
    - 주로 Closed-Source DB에서 사용
    - 장점
        - 최소 크기로 데이터를 얻을 수 있다. 데이터 교환이 거의 없어서 백업과 복원속도가 빠르다.
    - 단점
        - 일부 데이터의 교환이나 적용이 불가능하다
        - 플랫폼 의존 바이너리는 동일 DBMS라도 호환 X

### 풀 백업 vs 부분(증분/차등) 백업

- 풀 백업
    - **데이터베이스 전체 데이터를 매일 백업하는 방식**
    - 백업 데이터가 한군데에 모여 있어 복원 처리가 단순하다.
    - 그러나 데이터베이스 전체를 백업하므로 백업에 걸리는 시간이 길고, 갱신량이 적어도 매일 데이터베이스 전체를 백업하므로 백업 데이터를 저장하는 데 충분한 용량이 필요하다.

- 부분 백업
    - **우선 풀 백업을 한 후, 이후 갱신된 데이터를 백업**
    - 갱신된 데이터만을 대상으로 하므로 백업에 필요한 시간이 짧고, 백업 데이터의 용량이 작아도 문제없다.
    - 복원에는 풀 백업과 부분 백업이 필요해서 복원 절차가 복잡하다.
    - 차등(Differential) 백업
        - 풀에서 차등만 백업한 후, 최초의 풀 백업 + 최후의 차등 백업으로 복원
    - 증분(Incremental) 백업
        - 전일로부터의 증분만 백업한 후, 최초의 풀 백업 + 모든 증분으로 복원

### 롤 포워드 리커버리 (Roll Forward Recovery)

- 풀 백업 → ‘백업 시점’의 데이터들을 복원
- MySQL → ‘바이너리 로그(WAL)’를 증분 백업으로 보존하고, 이를 통해 풀 백업 시점 이후 임의 시점까지 복원하는 게 가능하다.

> 현재 Database = 풀 백업한 데이터 + 풀 백업 후 얻은 모든 증분 백업
> 

## 데이터베이스 관리 시 주의점

1. 백업 파일들은 떨어진 곳에 각각 보관해야 한다.
2. 항상 ‘장애는 언제든지 일어날 수 있음’을 명심해야 한다.
3. 각 장애 상황에 맞는 방법을 채택해야한다.
    1. 24시간 가동해야 하는 DB → Hot Backup
    2. VLDB (Very Large DB) → Physical Backup
    3. 갱신 범위가 매우 한정 → 차등 백업
# 9장 백업과 복구

## 회복의 개요

- 여러 응용프로그램이 주기억 장치 버퍼 내의 동일한 데이터베이스 항목을 갱신한 후에 디스크에 기록함으로써 성능을 향항시키는 것이 중요
- 버퍼의 내용을 디스크에 기록하는 것을 가능하면 최대한 줄이는 것이 일반적
  예: 버퍼가 꽉 찼을 때 또는 트랜잭션이 완료됬을 때 버퍼의 내용이 디스크에 기록될 수 있음
- 트랜잭션이 버퍼에는 갱신 사항을 반영했지만 버퍼의 내용이 디스크에 기록되기 전에 고장 발발 가능
- 따라서 고장 발생 전 " 트랜잭션이 완료 명령을 수행했다면 (이미 끝난 작업) " 회복 모듈은 이 트랜잭션의 갱신 사항을 <b>재수행(REDO)</b>하여 트랜잭션의 갱신이 지속성을 갖도록 해야함
- 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행하지 못했다면 원자성을 보장하기 위해 트랜잭션이 데이터베이스에 반영했을 가능성이 있는 갱신 사항을 <b>취소(UNDO)</b> 해야함.

### 재해적 고장과 비재해적 고장

1. 재해적 고장

- 디스크가 손상을 입어서 데이터베이스를 읽을 수 없는 고장
- 재해적 고장으로부터의 회복은 데이터베이스를 백업해 놓은 자기 테이프를 기반으로 함

2. 비재해적 고장

- 그 이외의 고장
- 대부분의 회복 알고리즘들은 비재해적 고장에 적용됨
- <b>로그를 기반으로 한 즉시 갱신</b>, 로그를 기반으로 한 지연 갱신, 그림자 페이징 등 여러 알고리즘
- 대부분의 상용 DBMS에서 로그를 기반으로 한 즉시 갱신 방식 사용

### 로그를 사용한 즉시 갱신

- 즉신 갱신에서는 트랜잭션이 데이터베이스를 갱신한 사항이 주기억 장치의 버퍼에 유지되다가 트랜잭션이 완료되기 "전"이라도 디스크의 데이터베이스에 기록될 수 있음
- 데이터베이스에는 완료된 트랜잭션의 수행 결과뿐만 아니라 철회된 트랜잭션의 수행 결과도 반영될 수 있음
- 트랜잭션의 원자성과 지속성을 보장하기 위해 DBMS는 <b>로그(log)</b> 라고 부르는 특별한 파일을 유지함
- 데이터베이스의 항목에 영향을 미치는 모든 트랜잭션의 연산들에 대해서 로그 레코드를 기록함
- 각 로그 레코드는 로그 순서 번호 (LSN : Log Sequence Number)로 식별됨

<img src="https://jihunn-kim.github.io/assets/img/2021-03-11-database_system_9/16.png">

- 주기억 장치 내의 로그 버퍼에 로그 레코드들을 기록하고 로그 버퍼가 꽉 찰 때 디스크에 기록.
- 로그는 데이터베이스 회복에 필수적이기에 일반적으로 안전 저장 장치(데이터의 손실이 발생하지 않게 여러 개의 비소멸 저장장치로 구성된 저장장치)에 저장됨
- 이중 로그 (Dual Logging): 로그를 두 개의 디스크에 중복해서 저장하는 것
- 각 로그 레코드가 어떤 트랜잭션에 속한 것인가를 식별하기 위해서 각 로그 레코드마다 트랜잭션 ID를 포함시킴
- 동일한 트랜잭션에 속하는 로그 레코드들을 연결 리스트로 유지함

<b> [로그 레코드 유형] </b>

- [Trans-ID, start] (start는 Log Type)
  -> 한 트랜잭션이 생성될 떄 기록되는 로그 레코드

- [Trans-ID, X, old_value, new_value] -> 업데이트 트랜잭션
  -> 주어진 Trans_ID를 갖는 트랜잭션이 데이터 항목 X를 이전값(old_value)에서 새값(new_value)로 수정했음을 나타내는 로그 레코드

- [Trans-ID, commit]
  -> 주어진 Trans_ID를 갖는 트랜잭션이 데이터베이스에 대한 갱신을 모두 성공적으로 완료하였음을 나타내는 로그 레코드

- [Trans-ID, abort]
  -> 주어진 Trans-ID를 갖는 트랜잭션이 철회되었음을 나타내는 로그 레코드

### 트랜잭션의 완료점 (Commit Point)

- 한 트랜잭션의 데이터베이스 갱신 연산이 모두 끝나고 데이터베이스 갱신 사항이 "로그에 기록되었을 때"
- DBMS의 회복 모듈을 로그를 검사하여 로그에 [Trans-ID, start] 로그 레코드와 [Trans-ID, commit] 로그 레코드가 모두 존재하는 트랜잭션들은 재수행
- [Trans-ID, start] 로그 레코드는 로그에 존재하지만 [Trans-ID, commit] 로그 레코드가 존재하지 않는 트랜잭션들은 취소

<img src="https://jihunn-kim.github.io/assets/img/2021-03-11-database_system_9/18.png">

## 로그 먼저 쓰기 (WAL : Write-Ahead Logging)

- 트랜잭션이 데이터베이스를 갱신하며 주기억 장치의 데이터페이스 버퍼에 갱신 사항을 기록하고, 로그 버퍼에는 이에 대응되는 로그 레코드를 기록함 (디스크와 무관)
- 데이터베이스 버퍼가 로그 버퍼보다 먼저 "디스크"에 기록되는 경우에는 먼저 기록되고 시스템이 다운되면, 로그 레코드가 없어서 이전값을 알 수 없으므로 트랜잭션의 취소가 불가능함. 따라서 데이터베이스 버퍼보다 "로그 버퍼" 를 먼저 디스크에 기록해야 함.

## 체크포인트(checkpoint) 필요성

- 시스템이 다운된 시점으로부터 오래 전에 완료된 트랜잭션들이 데이터베이스를 갱신한 사항은 이미 디스크에 반여되었을 가능성이 큼
- DBMS가 로그를 사용하더라도 어떤 트랜잭션의 갱신 사항이 주기억 장치 버퍼로부터 디스크에 기록되었는가를 구분할 수 없음 (기록은 했지만 내가 디스크에 어떤 어떤 로그 레코드들을 기록했지?)
- 따라서 DBMS는 회복시 재수행할 트랜잭션의 수를 줄이기 위해 주기적으로 체크포인트 수행

## 체크포인트 전략

- 체크포인트 시점에는 주기억 장치의 버퍼 내용이 디스크에 "강제"로 기록되므로 체크포인트를 수행하면 디스크 상에서 로그와 데이터베이스의 내용이 일치하게 됨
- 체크포인트 작업이 끝나면 로그에 <b>[checkpoint]</b> 로그 레코드가 기록됨.
- 일반적으로 10-20분 마다 한 번씩 수행함

## 체크포인트를 할 때 수행되는 작업

- 수행 중인 트랜잭션들을 일시적으로 중지시킴. 회복 알고리즘에 따라서는 이 작업이 필요하지 않을 수 있음 (= fuzzy checkpoint 즉, 중지하지 않고 체크포인트 뜰 수 있음)
- 주기억 장치의 로그 버퍼를 디스크에 강제로 출력
- 주기억 장치의 데이터베이스 버퍼를 디스크에 강제로 출력
- [checkpoint] 로그 레코드를 로그 버퍼에 기록한 후 디스크에 강제로 출력
- 체크 포인트 시점에 수행 중이던 트랜잭션들의 ID도 [checkpoint] 로그 레코드에 함께 기록
- 일시적으로 중지된 트랜잭션의 수행 재개

<img src="https://jihunn-kim.github.io/assets/img/2021-03-11-database_system_9/19.png">

<img src="https://jihunn-kim.github.io/assets/img/2021-03-11-database_system_9/20.png">

## 데이터베이스 백업과 재해적 고장으로부터의 회복

- 아주 드물지만, 데이터베이스가 저장되어 있는 디스크의 헤드 등이 고장나서 데이터베이스를 읽을 수 없는 경우 발생
- 이런 경우 데이터베이스를 회복하는 한 가지 방법은 주기적으로 자기테이프에 전체 데이터베이스와 로그를 백업하고, 자기 테이브를 별도의 공간에 안전하게 보관
- 사용자들에게 데이터베이스 사용을 계속 허용하면서, 지난 번 백업 이후에 갱신된 내용만 백업을 하는 <b>점진적인 백업(incremental backup)</b>이 바람직.

---

# 10장 - 성능을 생각하자

# 실행계획과 옵티마이저

프로 등산가가 경로를 정할 때, 최종적으로 산꼭대기(데이터)에 이르는 것이 목적이라고 한다면 등산자가 선택할 수 있는 경로는 여러 개가 있지만, 그중에서 가장 체력 소모가 적고 충분히 안전한 경로를 선택한 뒤 등산을 시작할 것이다.

이와 동일하게 SQL문에 필요한 데이터를 얻는 방법은 복수 개가 있을 수 있으므로 데이터베이스는 어떤 계획으로 데이터에 도달할지 결정해야 한다.

이 계획을 실행계획 또는 엑세스 플랜이라고 하며 실행계획을 결정하는 내부 프로그램을 "옵티마이저"라고 한다.

즉, SQL 실행문에 대해서 "어떻게" 그 데이터에 대한 조회/삭제/업데이트 등의 작업을 수행할지에 대한 방법론에 관한 것이다.

## 옵티마이저가 참조하는 통계정보

통계정보란 옵티마이저가 실행계획을 세울 때 참조하는 정보이다. 통계정보에 포함되는 대표적인 데이터는 다음과 같다.

1. 테이블의 행수.열수
2. 각 열의 길이와 데이터형
3. 테이블의 크기
4. 열에 대한 기본키나 NOT NULL 제약의 정보
5. 열 값의 분산과 편향

즉 앞서 등산에 대한 비유의 과정에서 위의 항목들은 '산의 지도나 일기예보'에 해당하는 것이다.

해당 정보들이 상세하면 할수록 최적의 등산 경로를 찾을 수 있는 것이다.

## 풀 스캔과 레인지 스캔

```
Database changed
mysql> EXPLAIN select * from City;
+------+-------------+-------+------+---------------+------+---------+------+------+-------+
| id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+------+-------------+-------+------+---------------+------+---------+------+------+-------+
|    1 | SIMPLE      | City  | ALL  | NULL          | NULL | NULL    | NULL | 4046 |       |
+------+-------------+-------+------+---------------+------+---------+------+------+-------+
1 row in set (0.00 sec)
```

- type : ALL -> 테이블에 대한 엑세스 방법을 나타냄

테이블로의 액세스 방법은 풀 스캔과 레인지 스캔 2가지가 존재한다. 풀 스캔은 테이블에 포함된 레코드를 처음부터 끝까지 전부 읽어 들이는 방법으로, 테이블 풀 스캔이라고 한다. 레인지 스캔은 테이블의 일부 레코드에만 엑세스하는 방법.

해당 테이블의 경우 ALL이 선택되었기 떄문에 처음부터 마지막까지 모든 페이지 엑세스 수행.

```
mysql> EXPLAIN select * from City WHERE id between 2391 and 2400;
+------+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id   | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+------+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|    1 | SIMPLE      | City  | range | PRIMARY       | PRIMARY | 4       | NULL | 10   | Using where |
+------+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
1 row in set (0.03 sec)
```

- type이 range로 변경되었으며 읽어들인 rows 수도 10으로 바뀌었다.

## 인덱스의 중요성

- possible_keys와 key열을 살펴보자
- 레인지 스캔을 하려면 인덱스가 꼭 필요하다.

인덱스가 없으면 어떤 단어가 서적의 몇 페이지에 있는 알 수 없어 책 전체를 훑어야 한다.

따라서, possible_keys와 key열에 있는 'PRIMARY'란 단어는 인덱스를 사용함을 나타낸다.
기본키의 인덱스라는 것을 의미하며 어떤 DBMS에서도 기본키를 구성하는 열에는 반드시 인덱스가 저장되어 있다.

```

mysql> show index FRom City;
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| Table | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| city  |          0 | PRIMARY     |            1 | ID          | A         |        4046 |     NULL | NULL   |      | BTREE      |         |               | NO      |
| city  |          1 | CountryCode |            1 | CountryCode | A         |         505 |     NULL | NULL   |      | BTREE      |         |               | NO      |
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
2 rows in set (0.02 sec)
```

- Key_name이 인덱스 열의 이름이다.
- 위의 예에서는 City 테이블에 PRIMAR, CountryCode Y라는 인덱스가 2개 있다는 걸 의미한다.

City 테이블은 ID 열이 키본키라서 이 열에는 반드시 인덱스가 존재한다. 바꿔 말하면 City 테이블의 다른 열에는 인덱스가 없으므로 가령 ID 이외의 열을 WHERE 구에서 범위 축소 조건으로 이용한다고 해도 레인지 스캔 X

```
mysql> EXPLAIN select * from City WHERE population between  20000 and 40000;
+------+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+------+-------------+-------+------+---------------+------+---------+------+------+-------------+
|    1 | SIMPLE      | City  | ALL  | NULL          | NULL | NULL    | NULL | 4046 | Using where |
+------+-------------+-------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.01 sec)
```

위처럼 인구 수에 대한 실행계획을 살펴보았을 떄 타입이 ALL로 되어있기에 전체 테이블을 샅샅이 훑고 결과를 반환 한다는 것을 알 수 있다.

## 인덱스는 SQL에서 만든다

풀 스캔 문제를 해결하기 위해 인덱스를 생성해 보자.

```
mysql> create index ind_population on city(population);
Query OK, 0 rows affected (0.30 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> show index from city;
+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| Table | Non_unique | Key_name       | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |
+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| city  |          0 | PRIMARY        |            1 | ID          | A         |        4046 |     NULL | NULL   |      | BTREE      |         |               | NO      |
| city  |          1 | CountryCode    |            1 | CountryCode | A         |         505 |     NULL | NULL   |      | BTREE      |         |               | NO      |
| city  |          1 | ind_population |            1 | Population  | A         |        4046 |     NULL | NULL   |      | BTREE      |         |               | NO      |
+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
3 rows in set (0.01 sec)
```

ind_population 이라는 인덱스가 생성된 걸 확인할 수 있다.
따라서 실행계획을 살펴봤을 때 테이블 풀스캔에서 레인지 스캔으로 변경된 걸 살펴볼 수 있다.

```
mysql> EXPLAIN select * from City WHERE population between  20000 and 40000;
+------+-------------+-------+-------+----------------+----------------+---------+------+------+-----------------------+
| id   | select_type | table | type  | possible_keys  | key            | key_len | ref  | rows | Extra                 |
+------+-------------+-------+-------+----------------+----------------+---------+------+------+-----------------------+
|    1 | SIMPLE      | City  | range | ind_population | ind_population | 4       | NULL | 19   | Using index condition |
+------+-------------+-------+-------+----------------+----------------+---------+------+------+-----------------------+
1 row in set (0.03 sec)
```

여기서 중요한 점은 단지 인덱스를 생성했을 뿐, 내가 만든 인덱스를 사용하라고 지정하지 않는다.
그럼에도 불구하고 DBMS는 풀 스캔보다 인덱스를 사용하는 쪽이 빠르다고 판단해 자동으로 인덱스를 사용하는 실행계획으로 바꾸었다.

추가적으로 특정 테이블안에서 특정 컬럼들간의 조합이 각 튜플들을 UNIQUE하게 식별하는 경우 (EX: team_id + backnumber)
인덱스는 create <b>UNIQUE</b> INDEX team_id_backnumber_idx ON Player(team_id, backnumber)와 같이 생성 가능

-> 이렇게 2개 이상의 에트리뷰트로 구성된 인덱스를 multicolumn index 혹은 composite index라고 칭한다.
-> 그리고 중요한 점 중에 하나가 더 있는데, create index (a,b)와 같이 할 경우, 즉 2개의 애트리뷰트에 대해서 인덱스를 설정하면 a를 기준으로 정렬이 된다. a의 값이 동일한 로우가 있다면 그 다음 b로 넘어가서 정렬.

그러므로, composite index를 설정하려면 인덱스 애트리뷰트 순서에 유의 !

## 인덱스의 구조

SQL 쿼리 성능을 빠르게 하는 가장 베이직한 방법은 인덱스 설정이다. 인덱스 활용도가 높은 이유는 다음과 같다.

1. SQL문 변경 필요 X
2. 테이블의 데이터에 영향 X
3. 일정한 (때론 극적인) 효과 기대 O

즉, 한마디로 비용 대비 성능이 높음.

이러한 인덱스의 구조는 B-tree구조.

비트리는 관계형 데이터베이스에서 튜닝의 기본이 되는 인덱스이다.

## 트리 구조의 우위성

비트리는 반드시 데이터를 정렬된 상태로 유지한다. 데이터가 순서를 유지하고 있다는 것은 비트리의 핵심이다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbifD6g%2FbtqTtp1mm3G%2F9w1yXpG1WLiWpzCyjh7uRk%2Fimg.png">

## 왜 B-tree는 빠른가

비트리의 장점 한가지는 어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다인데, 이를 균일성이라고 한다.

예를들어 고양이란 값이 존재하는 페이지를 찾을때도, '말'이란 값이 존재하는 페이지를 찾을 떄도 동일한 시간안에 찾을 수 있다라는 것이다.

이와 반대되는 개념이 선형탐색.

비트리는 트리 중에서도 특히 값에 따른 성능 불균형이 작도록 고안됨.

이는 비트리가 균형트리이기 떄문인데, 균형 트리는 루트로부터 리프까지의 거리가 일정한 트리 구조를 뜻하는 것이다.

하지만 비트리 역시 테이블에 대한 데이터 갱신이 반복되면 서서히 균형이 깨지기에 정기적으로 인덱스 재구성(Rebuild) 수행이 요구시됨.

## SQL 뒤편에서 일어나는 일 - 정렬

```
mysql> explain select population, count(*) from city group by population;
+------+-------------+-------+------+---------------+------+---------+------+------+---------------------------------+
| id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                           |
+------+-------------+-------+------+---------------+------+---------+------+------+---------------------------------+
|    1 | SIMPLE      | city  | ALL  | NULL          | NULL | NULL    | NULL | 4046 | Using temporary; Using filesort |
+------+-------------+-------+------+---------------+------+---------+------+------+---------------------------------+
1 row in set (0.02 sec)
```

type : ALL -> 풀 스캔, key : NULL -> 인덱스 사용 X

주목 지점은 Extra열의 Using temporary; Using filesort -> 정렬을 위한 임시 영역에 파일 처리 했음을 뜻함.

즉, HDD에 저장소가 사용되었고 이는 성능 문제 야기 원인 .

```

mysql> create index ind_population on city(population);
Query OK, 0 rows affected (0.23 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select population, count(*) from city group by population;
+------+-------------+-------+-------+---------------+----------------+---------+------+------+-------------+
| id   | select_type | table | type  | possible_keys | key            | key_len | ref  | rows | Extra       |
+------+-------------+-------+-------+---------------+----------------+---------+------+------+-------------+
|    1 | SIMPLE      | city  | index | NULL          | ind_population | 4       | NULL | 4046 | Using index |
+------+-------------+-------+-------+---------------+----------------+---------+------+------+-------------+
1 row in set (0.01 sec)
```

인덱스 재생성 후 Extra를 살펴보면 Using index임을 알 수 있다.
이처럼 Group by 구의 키로 지정한 열에 인덱스 존재 시, 필요한 정렬 처리 건너뛸 수 있음

<b> 정렬 연산이 요구되는 연산 </b>

- Group by
- 집약 함수 (COUNT/SUM/AVG)
- 집합 연산 (UNION/INTERSECT/EXCEPT)

다음과 같은 연산 수행 시 정렬의 키가 되는 열이 필요하므로 해당 키 열에 인덱스가 존재하면 옵티마이저가 이용해서 정렬을 건너뛴다.

## 인덱스 작성이 역효과가 나는 예

인덱스는 테이블에 새로운 데이터 추가 혹은 기존 데이터 갱신 / 제거 시, 자동으로 인덱스 자신도 갱신 수행
이것 자체는 우수한 기능이지만 그 대가로 인덱스가 존재하지 않는 떄와 비교 하면 매번 인덱스 갱신도 부수적으로 발생 하기에 오버헤드 여지를 주는 것.

<b> 의도한 것과 다른 인덱스가 사용된다 </b>

한 개의 테이블에 복수의 인덱스를 설정할 경우에 파생될 수 있는 문제점.

사용할 수 있는 인덱스 후보가 많으면 옵티마이저도 헤메게 될 뿐더러 인덱스 역시 백업 대상이기에 백업 시 소요시간이 요구된다.

## 인덱스 생성 기준

- 1. 크기가 큰 테이블만 생성

- 2. 기본키 제약이나 유일성 제약이 부여된 열에는 불필요.

-> 기본키에는 어차피 인덱스가 기존에 존재하며 유일성 재약이 붙어있는 열도 마찬가지

이 2가지 제약이 붙어 있는 열에 암묵적으로 인덱스가 작성된 것은 값의 중복 체크를 하려면 데이터를 정렬해야 하는데 인덱스를 작성해 정렬하는 것이 편리.

- 3. Cardinality가 높은 열에 생성

카디널리티는 상대적인 개념으로서 가령 사람의 주민번호 경우 중복이 될 여지가 적기에( = unique한 값의 갯수가 많다.) 카디널리티가 높고, 이름의 경우 동명이인이 있을 수 있기에 주민번호에 비해 "상대적"으로 카디널리티가 낮다.

커디널리티가 높은 순으로 필터링 하여 조회하기에 높은 순에서 낮은 순으로 구성하는 것이 좋다. ( = 낮은 열에 인덱스 효과를 기대할 수 없는 것은 인덱스 트리를 따라가는 조작이 증가 )

- 테이블 조인을 위해 연결고리로 자주 사용되는 컬럼

조인 쿼리에 사용되는 컬럼의 경우 풀스캔을 타게 되면 조인의 수가 늘어날 수록 풀스캔하는 데이터 수가 많아지므로 병목현상의 대표적인 원인이 된다.

### [외않돼? 타임] 인덱스를 만들었는데 인덱스를 참조하질 않아요 (USE INDEX)

특정 테이블에 index를 걸었더라도 해당 index가 작동하지 않을 수도 있다. 이유는 여러가지겠지만 Mysql이 내부적으로 가장 빠르거나 합리적인 탐색법을 사용하기 때문이다. 그럴 경우엔 Hint 기능을 써서 USE INDEX를 사용해서 인덱스를 강제로 작동시키게 할 수 있다. -> 이렇게 하는 이유는 근본적으로는 인덱스 갯수가 여러개이기 때문.

```
SELECT *
FROM IMAGE USE INDEX(USER_ADD_ID)
WHERE add_id = '2bf-ad7c-1b24'
```

참고 - 힌트(Hint)기능을 쓰는 이유는 옵티마이저(Optimizer)가 항상 최적의 실행 경로를 만들어 내기는 불가능하기 때문에 개발자가 최적의 경로를 지정해주는 것을 말한다. 옵티마이저 힌트와 인덱스 힌트로 나뉘며 무분별한 힌트의 사용은 성능의 저하를 초래한다

ref :https://stir.tistory.com/236

### 추가 - 클러스터링 인덱스 vs 논-클러스터링 인덱스 (=세컨더리 인덱스)

#### 1. 클러스터링 인덱스 ( 실제 데이터와 "같은" 무리의 인덱스 )

- 테이블의 "PK"에 적용되는 인덱스이다
- PK값이 비슷한 레코드끼리 묶어 저장하는 것을 클러스터링 인덱스라고 한다.
- PK값에 의해 해당 레코드의 물리적인 저장 위치가 결정 (PK값이 바뀌면 해당 레코드의 물리적인 저장 위치도 변경됨)
- PK 값을 기준으로 정렬된 상태를 유지한다.

<img src="https://akasai.space/static/c1456b22b1d2478f6f085037c1895161/59822/ci.png">

- B - Tree 구조로 이루어짐
- idx-1, idx-2 ... 는 데이터페이지의 주소값을 가리킴
- 루트페이지와 리프페이지로 구성되며 루트페이지는 리프페이지의 주소가, 리프페이지에는 "실제 데이터" 를 담고 있다.
  인덱스의 정보를 담고 있는 것이 아닌 모든 컬럼에 대한 실제 데이터를 담고 있다. 따라서, 따라서리프페이지 == 데이터페이지이다.

<b> 특징 </b>

1. 실제 데이터가 정렬 따라서, 테이블 당 1개만 존재 가능
2. 리프페이지 == 데이터페이지
3. 다음 제약조건 시 자동생성 (PRIMARY KEY , UNIQUE + NOT NULL) , 둘 다 있으면 PRI 우선

<b> 주의 사항 </b>

1. PK는 AUTO_INCREMENT보다는 업무적인 컬럼으로 생성 (가능한 경우)

- InnoDB의 PK는 클러스터링 키로 사용되며 이 값에 의해 레코드의 위치가 결정된다.
- PK는 대부분 검색에서 빈번하게 사용되므로 PK의 크기가 조금 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 PK로 선택하는 것이 좋다.

2. PK는 반드시 명시할 것

- 가능하면 AUTO_INCREMENT를 사용하더라도 PK를 꼭 만들자.
- PK가 없고 NOT NULL + Unique 인덱스도 없으면 InnoDB 내부적으로 일련 번호 컬럼을 추가한다.
- 이렇게 자동으로 생성된 컬럼은 사용자에게 보이지도 않고, 사용자가 전혀 접근할 수도 없으므로 의미가 없는 값이 된다.

3. AUTO_INCREMENT 컬럼을 인조 식별자로 사용할 경우

- PK의 크기가 커도 세컨더리 인덱스가 거의 필요 없다면 그대로 PK를 사용하는 것이 좋다.
- 세컨더리 인덱스도 필요하고 PK의 크기가 크다면 AUTO_INCREMENT 컬럼을 추가하고, 이를 PK로 지정하면 된다.
- 이렇게 업무 상의 의미를 지닌 PK를 대체하기 위해 AUTO_INCREMENT과 같은 방식을 사용하여 인위적으로 추가된 PK를 인조 식별자라고 부른다.

#### 2. 논-클러스터링 인덱스 ( 실제 데이터와 "다른" 무리의 인덱스 )

테이블 생성 시 UNIQUE 제약조건을 걸게되면 자동적으로 논-클러스터링 인덱스가 생성되며 개념적으로 후보키에만 부여할 수 있는 인덱스다. (후보키 : 고유 식별 번호, 주민번호와 같이 각 데이터를 인식할 수 있는 최소한의 고유 식별 속성 집합)

<img src="https://akasai.space/static/eec01f16f19cd30d966175bc38681da6/4352a/nci.png">

- 데이터 페이지 (실제 데이터가 저장된 곳) -> 어떠한 정렬 / 변경도 이뤄지지 않음
- 데이터 페이지 == 리프 페이지 였던 클러스터링 인덱스와는 달리 별도의 인덱스 페이지 생성 (B-tree 구조는 동일)
- 따라서, 이처럼 추가공간이 요구되기에 세컨더리 인덱스를 남용하면 공간 낭비와 부하로 이뤄질 수 있다.
- d-1, d-2는 데이터 위치에 대한 주소값을 가지고 있음
  -> RID(Row Identifier) 라고 한다.
- 클러스터형 보다 검색 속도는 더 느리지만 데이터의 입력/수정/삭제는 더 낫다.
- 각 데이터에 대해서 고유 값 (unique) 들이 있는 목록에 생성 할 수 있는 인덱스다. (unique key)

<b> 특징 </b>

1. 실제 데이터 페이지는 어떠한 변경도 없이 그대로 존재
2. 별도의 인덱스 페이지 생성 -> 추가 공간 필요
3. 테이블 당 여러개 존재
4. 리프페이지에 실제 데이터 페이지 "주소"를 담고 있음
5. 직접 index 생성 시 논-클러스터링 인덱스가 생성됨

#### 3. 클러스터 + 보조(세컨더리) 인덱스

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FblV2ZG%2FbtqHvJwaMBI%2FvipT4KRcjkdYpHi8ZZbdp1%2Fimg.png">

클러스터 인덱스 페이지에 보조 인덱스 페이지가 따로 만들어져 연결됨을 볼 수 있다.
가령 위에서 '임'재범을 찾게된다면 보조 인덱스 페이지에서 임재범 LJB를 따라가다가 다시 클러스터 인덱스 루트 페이지로가 LJB로 검색하며 찾아들어가게 된다.

여기서 주의깊게 쳐다봐야 할 지점은 기존에 보조 인덱스의 경우에는 인덱스 페이지를 만들어 데이터페이지를 가리키는 RID를 사용했지만 클러스터 + 보조 인덱스 구조에서는 RID가 아닌 클러스터 인덱스의 "실제" 값(PK)을 가지고 찾아들어간다.

이렇게 하면 주솟값으로 바로 점프를 하지 못하고 루트 페이지도 읽어야 하고 데이터페이지도 동시에 읽어야 하는데 왜 그럴까?

정답은 RID로 데이터를 저장하면 삽입 삭제 시 인덱스 페이지가 완전히 뒤집어져야 하기 때문이다. 데이터를 추가하게 되면 데이터가 정렬되어야 하기 때문에 RID가 바뀔 것이고 모든 데이터에 연쇄 반응을 일으킨다. 더불어 보조 인덱스 페이지가 바뀌면 클러스터 인덱스 페이지도 바꿔줘야 한다.

즉, 검색으로 얻는 이득 보다, 삽입 삭제시 잃는 성능이 더 크기 때문에 RID말고 PK를 저장하게 구성 된 것이다.

#### [MySQL의 특이점]

일반적인 DBMS에서 세컨더리 인덱스를 생성하면 리프 노드(Leaf node)에는 그 데이터가 있는 실제 물리 주소를 가지고 있다가 해당 인덱스가 사용되면 바로 데이터를 가져온다.

하지만 MySQL에서의 세컨더리 인덱스는 "프리머리 키 값" 을 저장하게 되어 있습니다. 그래서 쿼리 실행시 세컨더리 인덱스를 사용하게 되면 해당 인덱스에 저장되어 있는 프리머리 키값을 찾아간다.

즉, 세컨더리 인덱스 -> 프리머리 키 -> 찾고자 하는 데이터

모든 세컨더리 인덱스가 프리머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많이 있습니다.

#### 인덱스 적용 기준 (추천)

1. 카디널리티가 높은 ( = 중복도가 낮은) 컬럼
2. WHERE, JOIN, ORDER BY 절에 자주 사용되는 컬럼 (WHERE 절에 사용되는 열 (WHERE 절에 사용되는 열이라도 자주 사용해야 가치가 있음)

- 조건절이 없다면 인덱스가 사용되지 않기 때문.
- ORDER BY 사용할 땐 클러스터 인덱스가 자동 정렬이 되어 있기에 유리

3. INSERT / UPDATE / DELETE 가 자주 발생하지 않는 컬럼
4. 규모가 작지 않은 테이블

#### 인덱스 적용 기준 (비추천)

1. 대용량 데이터가 자주 입력되는 경우
   클러스터형 인덱스의 경우 빈번한 페이징이 일어나기 때문에 부하가 생긴다.
   따라서 인덱스가 필요한 경우 primary(클러스터) 대신 unique만 설정하는 게 좋을 수 있다.

2. 데이터 중복도가 높은 열은 인덱스 효과가 없다.
   성별 처럼 중복도가 높은 열에는 쓰나마나.
   따라서 일반 보조 인덱스보다 unique 보조 인덱스가 빠르다.

3. 자주 사용되지 않으면 성능 저하를 초래할 수 있음. (INSERT만 주구장창 하는 시스템이라면, 사용해보지도 못하고 데이터 입력에 걸리는 작업량만 많아진다)

ref : https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC
https://www.youtube.com/watch?v=IMDH4iAQ6zM

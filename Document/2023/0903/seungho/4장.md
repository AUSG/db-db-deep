# 20230903 스터디 1주차

Edited by Seungho Song

## 4장 : 데이터베이스와 아키텍처 구성
#### 아키텍처란
: 시스템을 구축하기 위한 '물리적 레벨'에서의 조합을 뜻한다.
-> 아키텍처를 보면 해당 시스템이 무슨 목적으로 설계되었는지를 확인할 수 있다.
### 아키텍처 설계의 중요성
아키텍처를 잘 설계한다는 것은 곧 '돈'과도 연결되어 있다.

### 역사적 관점에서 아키텍처의 변천사
1. Stand-alone : 네트워크 접속 없이 독립적으로 구성된 데이터베이스 서버 머신을 말한다.
    - 미들웨어 (DBMS)와 애플리케이션 (Software)가 하나의 서버에서 동작
    - 단점
        1. 네트워크 연결X -> 매번 해당 서버가 있는 물리적 위치까지 가서 연결해야한다.
        2. 여러 사용자가 동시 작업 X
        3. 가용성(Availability, 시스템이 중단 없이 서비스를 지속할 수 있는 비율)이 낮다.
        4. 확장성(Scalability, 시스템을 개선할 수 있는 가능성)이 낮다.
    - 장점
        1. 구축이 간단하여 소규모 작업 시 빠르게 테스트할 수 있다.
        2. 보안이 매우 높다 <- 네트워크가 연결되어 있지 않으니 반강제(?)적으로 높아진다.
    - 총평 : 보안이 높다고 한들 네트워크가 연결 안되어 있다는게 치명적으로 다가온다.
2. Client-Server (2계층 구성) : 시스템이 클라이언트와 서버 2계층으로 구성
    - DB 서버에서는 DBMS가 동작
    - 클라이언트에서는 업무 애플리케이션이 동작
    - Stand-alone에 비해 네트워크가 연결되어 있어 망이 연결되어 있는 한 원격에서 통신할 수 있다. 또한 망 내의 여러 사용자가 동시작업 할 수 있다.
    - 단점
        - 어디까지나 닫힌 네트워크(LAN)에서 이용되므로, 외부 네트워크에서 접속 불가능.
    - 이후에 인터넷으로 연결하는 Client-Server가 가능해져서 위의 단점은 없어졌더라도, 인터넷에서 '직접' 데이터베이스에 접근한다는 보안성 저하문제와 클라이언트에서 애플리케이션이 동작하는 비용부담 문제가 있다.
3. Web 3계층 : 서버를 3계층(웹 서버 - 애플리케이션 - DB)으로 구성하는 방식
    - 기존 방식은 DB 서버에서 클라이언트로 애플리케이션의 버그를 수정한 버전을 배포하더라도, 클라이언트의 다른 환경에 각각 호환하기가 쉽지 않았다. -> 각 환경에 대응하기 위한 비용문제
    - 따라서 대체 방식이 필요했고, 그 결과 Web 3계층 방식을 채택하게 된다.
    - 웹 서버 (WS) : 클라이언트로부터 접속 요청을 받고, 요청에 대한 처리를 애플리케이션 계층으로 넘긴다. 추후 애플리케이션으로부터 결과 처리가 오면 그 데이터를 클라이언트로 전송한다. (예: Apache, IIS...)
    - 웹 애플리케이션 서버 (WAS) : 비즈니스 로직을 구현한 애플리케이션이 동작하는 층. 웹 서버로부터 연계된 요청 처리 및 DB 접속하여 데이터 추출.
    - 특징
        1. 비즈니스 로직을 실행하는 애플리케이션을 '서버'에서 관리 -> 클라이언트 관리비용 절감
        2. 데이터 보안 증가 (클라이언트 입장에서 DB 접근이 상당히 어렵기 때문에)
        3. 현재 웹 구조의 주류 방식
#### 그러나 Web 3계층까지 왔더라도 가용성과 확장성 문제는 해결하지 못했다.
### 아키텍처의 가용성과 확장성
- 가용성이 낮다 : 장애가 발생하면 서비스가 정지할 가능성이 높다
- 확장성이 부족하다 : 해당 서버의 성능이 저하될 경우, 하드웨어를 교환하여 성능 높이는 거 말고는 개선 방법이 없다.

### 가용성을 높이는 방법
1. 심장 전략 (고품질 - 소수전략) : 시스템의 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제
2. 신장 전략 (저품질 - 다수전략) : 시스템의 각 컴포넌트의 여분을 많이 준비해 하나가 고장나도 대체제로 빠르게 전환하는 전략 (물량작전)
    - 마인드 : "사물은 언젠가 망가진다"
#### 대체적으로 신장 전략을 많이 사용하지만, 심장 전략도 간간히 사용되며 두 전략을 혼용하여 쓰기도 한다.

### 클러스터링
동일한 기능의 컴포넌트를 병렬화하는 것. (신장 전략 채택)
- 클러스터 구성으로 시스템의 가동률을 높이는 것을 'Redundancy 확보' 또는 '다중화'라 한다.
- 가동률을 높인다 = 장애 발생률이 낮다
#### 단일 장애점 (Single Point Of Failure)
- 다중화되어있지 않아 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트
- 주로 이 지점이 가장 중요한 컴포넌트다.
- 다중화의 정도와 비즈니스 비용 간 트레이드오프를 고민해야한다.

### DB 서버의 다중화 - 클러스터링
#### DB 서버의 다중화가 더욱 중요한 이유 : 데이터는 영속성을 가지기 때문이다.
    - 영속성 : 데이터를 보존하는 속성. 대량의 데이터를 영구적으로 보존해야하는 DB는 영속성을 가진다.
    - 따라서, DB 아키텍처는 DB 서버와 저장소를 함께 생각해야한다.

### 기본적인 다중화 방법
1. Active-Active : 클러스터를 구성하는 컴포넌트들을 동시에 가동한다.
    - 특징
        1. 비싸다.
        2. 하지만 성능이 좋다.
        3. 하나가 장애 생겨도 다른 하나가 계속 처리할 수 있어 가장 가용성이 좋다.
        4. 다만, 단일 저장소에 다수의 서버가 연결되어 있는 형태라, 단일 저장소가 병목이 된다. (향상 정도에 한계가 있음)
2. Active-Standby : 실제 가동중인 Active 컴포넌트만 동작하고, 남은 컴포넌트는 대기(Standby)하고 있다.
    - 1단계 : Active 서버에 장애 발생
    - 2단계 : Standby 서버는 평소에 지속적으로 Active 서버에 신호 보내다가 장애 발생 감지 후 인식
    - 3단계 : Standby DB 서버 작동
    - Standby DB의 종류
        - Hot-Standby : 평소에도 Standby DB 작동
        - Cold-Standby : 평소엔 작동 X, Active DB 장애로 다운 시 작동 시작
#### 하지만, 클러스터링은 어디까지나 서버 다중화다. 저장소까지 다중화하지 않아 데이터 다중화가 되지 않았다는 단점. 만약 이때 저장소가 부서진다면..? 끔찍
-> Replication 도입

### DB 서버의 다중화 - Replication

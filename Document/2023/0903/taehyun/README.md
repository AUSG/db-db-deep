# 디비 디비 딥(DB DB Deep) 스터디 1회차

## 1강 데이터베이스란 - 용도와 역할

### 데이터베이스의 기본 기능

#### 데이터의 검색과 갱신

데이터베이스의 용도로써 가장 중요한 기능은 검색이다. 이는 곧 추출이라고도 하며, 원하는 데이터를 찾는 것이 데이터베이스의 용도로 가장 중요하다.

또한 새로운 데이터를 등록하고 기존 데이터를 수정하며 불필요해진 데이터를 제거하는 것도 가능해야 한다. 이때 등록, 수정, 제거를 일컬어 갱신이라 부른다.

데이터베이스를 조작할 때 중요한 것은 데이터를 어떤 형식(Format)으로 관리해야 검색이나 갱신에서 효율적인가 등에 대한 문제이다. 예를 들어 `이태현` 이라는 이름의 인물이 데이터베이스에 2명 존재할 경우 이름이 동일한 다른 인물이란 것을 데이터베이스 또한 알수 있게 해야한다. 이러한 원칙을 고유성(Uniqueness)이라 하며, 데이터베이스에서 데이터를 관리할 때 기초적인 규칙 중 하나이다.

마지막으로 갱신 등을 통해 데이터베이스 내 데이터의 양은 계속해서 증가할 수밖에 없기 때문에 검색 성능을 어떻게 향샹할 것인지 고민하는 건 늘 중요하다.

#### 동시성 제어

데이터베이스는 동시에 복수의 사용자로부터 검색이나 갱신 처리를 받기 때문에 갱신의 무결성을 어느 정도로 보장할지 고민해야 한다. 이는 다른 말로 동시성 제어 또는 배타 제어라고 한다.

다시 말해 복수의 사용자가 동시에 데이터베이스를 공유하고 이용하려 하는데 같은 데이터를 갱신하는 상황에 대한 제어가 필요한 것이다. 이때 사용자의 행위를 제한하는 수준에 따라 트레이드 오프가 발생하기 마련이다.

예를 들어, 동시에 두 명의 사람이 하나의 파일에 접근한다고 가정했을 때 두 명 모두 동시에 파일을 여는 것이 가능하고 나중에 수행된 갱신 행위가 반영되는 처리 방법을 더티 쓰기(Dirty Write)라 한다. 그러나 이것은 일반적으로 데이터 무결성 관점에서 기피하는 방법이다.

#### 장애 대응

데이터베이스는 중요한 정보를 모으는 시스템의 심장과도 같은 역할이기 때문에 데이터 보호와 장애 대책에 예민해야 한다.

데이터 소실을 막는 대표적인 방법으로는 크게 데이터 다중화와 백업이 있다. 데이터 다중화란 데이터를 한 곳이 아니라 복수의 장소에 분산해서 유지하는 것으로 예방책에 해당한다. 백업이란 데이터 소실이 발생했을 때 데이터를 복원하는 방법으로 사후대책이라 할 수 있다.

#### 보안

데이터베이스에 요구되는 기본 기능 중 보안도 존재한다.

먼저 사용자는 서버를 의식할 필요 없이 보통 그들과 가까운 기술은 클라이언트 기술 중심이다. 따라서 사용자가 시스템을 사용할 때 직접 조작하게 되는 건 클라이언트와 그 위에서 작동하는 프로그램 뿐이며 서버에 배치된 데이터베이스 등의 소프트웨어를 직접 조작할 일은 없다. 만약 이게 가능할 경우 시스템의 결함이다.

다음으로 데이터베이스 내에 존재하는 데이터의 기밀성이 높기 때문에 정보 유출의 위에 항상 조심해야 한다. 따라서 사용자가 데이터베이스에 접근할 수 없도록, 더 나아가 사용자가 데이터베이스의 존재조차 의식하지 않는 게 좋다.

### 데이터베이스의 종류

#### 계층형 데이터베이스

데이터를 계층 구조로 관리하는 데이터베이스다.

#### 관계형 데이터베이스

2차원 표 형식으로 데이터를 관리하는 데이터베이스로, 현재 가장 주류를 이루고 있다.

#### 객체지향 데이터베이스와 XML 데이터베이스

각각 '객체'와 'XML'이라는 형식으로 데이터를 관리하는 데이터베이스다.

#### NoSQL 데이터베이스

관계형 데이터베이스에 있는 일부 기능을 포기하는 대신 높은 처리 속도, 다시 말해 성능을 가진다. 대량의 데이터를 고속으로 처리해야 하는 웹 서비스와 잘 맞아서 최근 자주 이용되고 있다.

## 2강 관계형 데이베스란 - 가장 대표적인 데이터베이스

### 관계형 데이터베이스란

#### 관계형 데이터베이스란 무엇인가

관계형 데이터베이스(Relational Database, RDB)는 쉽게 데이터를 2차원 표를 사용해 관리하는 데이터베이스를 의미한다. 이때 관계(Relational)는 2차원 표를 표기할 때 사용하는 단어다.

#### 관계형 데이터베이스의 이점

관계형 데이터베이스는 프로그래밍 언어를 사용하지 않아도 데이터를 조작할 수 있다는 것이다. 그리고 이는 곧 SQL이라는 관계형 데이터베이스를 다루는 언어를 통해 가능하다.

### SQL 기초 지식

#### SQL이란

SQL(Structured Query Language)이란 관계형 데이터베이스가 데이터를 조작하기 위해 준비한 언어다. 여러 관계형 데이터베이스는 공통으로 SQL을 사용 중에 있다.

#### 테이블, 행, 혈의 의미

관계형 데이터베이스에 2차원 표는 테이블(Table)로 불린다. 테이블은 관계형 데이터베이스에서 데이터를 관리하기 위한 유일한 단위이기 때문에 어떤 테이블에 어떤 데이터를 포함하는지 결정하는 건 시스템의 기능을 좌우하는 중요한 의미가 된다.

테이블은 또한 2차원 축이 있기 때문에 일반적인 2차원 표와 마찬가지로 열(Column)과 행(Row)이 존재한다.

### 관계형 데이터베이스를 다루기 위한 사전 지식

#### DBMS와 데이터베이스의 차이

데이터베이스의 기능을 제공하는 소프트웨어를 데이터베이스 관리 시스템(Database  Management System, DBMS)이라고 부른다. 이때 관계형 데이터베이스에 한정하는 것을 강조하고 싶은 경우 단어 앞에 관계(Relational)를 붙여 관계형 데이터베이스 관리 시스템(Relational Database Management System, RDBMS)라 부르기도 한다.

데이터베이스와 이러한 DBMS를 구분하지 않고 사용하는 경우가 많지만 실제로 데이터베이스는 기능이나 구조를 나타내는 추상적인 개념이며 DBMS는 이 추상적인 개념을 표현한 구체적인 소프트웨어를 의미한다. 결국 MySQL 같은 소프트웨어는 DBMS이지만 데이터베이스는 아니다.

#### 소프트웨어와 데이터베이스의 관계

시스템은 단순히 데이터베이스만으로 구축할 수 없으며 다른 여러 가지 소프트웨어와 조합해서 만들어야 한다. 그리고 이러한 작업을 시스템 통합(System Integration, SI)이라 한다.

소프트웨어는 크게 운영체제, 미들웨어, 애플리케이션으로 구분할 수 있는데 각각의 소프트웨어는 계층성이 있으며 한 계층(Layer)의 소프트웨어가 작동하지 않으면 상위 계층의 소프트웨어 또한 작동하지 않는 의존성을 가지고 있다. 이때 DMBS는 미들웨어 계층에 위치하여 애플리케이션 계층과 운영체체 계층을 이어주는 역할을 한다.

운영체제(Operating System, OS)란 시스템을 작동하게 하기 위한 일종의 토대가 되는 기능을 제공하는 소프트웨어다. 대표적으로 Windows, Linux, Unix 등이 있다.

미들웨어(Middleware)는 단어 그대로 중간을 의미하는, 중간 소프트웨어로 앞서 이야기한 것처럼 데이터베이스는 여기에 속한다. 따라서 데이터베이스는 운영체제에 설치되어 작동된다.

이때 운영체제의 종류와 DMBS의 종류는 서로 여러 조합이 가능한데 운영체제나 DBMS가 기능에 대한 표준 규칙을 따르고 있고 어느 정도의 이식성이 있기 때문이다. 그래서 하나의 조합에서 다른 조합으로 시스템을 변경할 수도 있는데 이를 마이그레이션(Migration)이라 한다. 물론 SQL Server의 경우 Windows 운영체제 위에서만 작동하기 때문에 조합에 한계가 있을 수 있다.

마지막으로 애플리케이션(Application)이란 업무용 기능을 가진 프로그램된 소프트웨어로, 사용자가 가장 빈번하게 조작하는 소프트웨어다. 여러 업무에서 기존 인력에 의해 운영되던 처리, 다시 말해 비즈니스 로직 또는 비즈니스 룰을 프로그램으로 자동화하여 효율성을 높이고 비용을 줄일 수 있게 된다. 애플리케이션은 주로 Java 등과 같은 프로그래밍 언어를 사용하여 직접 제작하는 스크래치(Scratch) 방법과 다른 상용 애플리케이션 소프트웨어, 다시 말해 패키지(Package)를 사는 방법이 있다.

#### 애플리케이션과 데이터베이스의 관계

애플리케이션과 데이터베이스의 관계에서는 애플리케이션이 사용자와 데이터베이스 사이를 비집고 들어가 있다는 것이 중요하다. 결국 사용자가 데이터베이스를 직접 조학하는 것이 아닌 애플리케이션을 매개로 하여 데이터베이스에 접근하게 된다.

이는 앞서 이야기한 보안은 물론 업무 로직을 애플리케이션에 집중시켜 개발이나 수정에 걸리는 비용을 낮출 수 있는 이점이 있기 때문이다.

## 3강 데이터베이스에 얽힌 돈 이야기 - 초기비용과 운용비용

### 데이터베이스의 초기비용

#### 시스템의 전체비용 내역

시스템 전체를 볼 때 중요하게 여겨지는 비용 분류는 초기비용과 운영비용이다. 초기비용은 쉽게 최초에 지급하는 돈을 의미하며, 운영비용은 서비스를 이용하는 기간에 계속해서 지급하는 돈을 의미한다.

시스템 개발에서 초기비용으로써 대표적인 것은 서버나 네트워크 기기와 같은 하드웨어 구매비용이나 프로그램 개발을 위해 엔지니어나 프로그래머에게 지급하는 급여가 있다. 운영비용의 경우 시스템 가동 후 장애 대응이나 프로그램 수정과 같은 유지보수 비용이 포함된다.

#### 데이터베이스의 초기비용

데이터베이스를 도입할 때의 초기비용은 소프트웨어 라이선스(License) 요금이다. 라이선스 요금이란 다시 말해 소프트웨어 사용허가료다.

라이선스 요금의 경우 물리적인 단위가 아닌 논리적인 단위로 판매가 되며 판매 단위가 크게 두 가지로 나뉘는데, 프로세서 라이선스(Processor License), 사용자 라이선스(User License)가 있다. 프로세서 라이선스의 경우 DBMS를 설치해서 작동하는 하드웨어의 CPU 성능에 따라 가격이 결정되며, 사용자 라이선스의 경우 DBMS를 이용하는 사용자 수에 따라 가격이 결정되는 라이선스 체계다. 결국 두 라이선스 모두 시스템의 규모를 측정하기 위한 척도다.

### 데이터베이스의 운영비용

#### 데이터베이스의 운영비용

데이터베이에서의 운영비용은 기술지원 비용을 의미한다.

#### 기술지원 수준은 매년 내려간다

제품이 배포되고 한동안은 제품을 널리 보급하기 위해 벤더에서 다양한 기술지원을 제공하지만 점차 서비스 레벨이 낮아지다가 최후에는 신규 버그에 대한 패치를 제공하지 않으며 기술지원을 종료한다. 이 타이밍을 EOSL(End Of Service Life)이라 부른다.

#### 구매 시기와 기술지원 시기는 관계없음

이런 소프트웨어의 수명이라는 것은 사용자가 라이선스를 지급하고 구매한 날이 아니고 어디까지나 소프트웨어가 세상에 배포(Release)된 날을 기준으로 산정한다.

### 초기비용과 운영비용의 조합


#### 오픈소스를 이용한다

초기비용은 없지만 운영비용은 있는 예시는 오픈소스 소프트웨어(Open Source Software, OSS)를 이용하는 것이다. 라이선스 비용은 무료이지만 보통 기술지원 비용을 유상으로 하여 판매하곤 한다.

#### 임대 모델

최근에는 데이터베이스 또한 AWS(Amazon Web Services) 등의 클라우드 서비스에서 제공되어 시험 삼아 사용해보고 싶은 라이트 사용자에게 선택 폭이 넓어지고 있다. 최근 기업들이 고정자산을 줄이고 임대로 해결하려는 '소유하지 않는 경영'을 주목하고 있는데, 소프트웨어 또한 이러한 요구에 따라 임대 모델이 등장한 것이다. 이때 미들웨어까지 포함한 클라우드 서비스의 임대 모델을 PaaS(Platform as a Service)라고 한다.

## 4강 데이터베이스와 아키텍처 구성 - 견고하고 고속희 시스템을 구축하기 위해

### 아키텍처란

#### 아키텍처 설계의 필요성

아키텍처(Architecture)란 말은 다양한 의미가 있지만, 시스템을 만들기 위한 물리 레벨의 조합이란 의미를 가지고 있다. 구체적으로 어떤 기능을 가진 서버를 준비하고, 어떠한 저장소나 네트워크 기기와 조합해서 시스템 전체를 만들 것인지 하드웨어와 미들웨어의 구성을 설계하고 신경쓰는 것을 의미한다. 그리고 이때의 구성을 시스템이 완수해야 할 목적과 비교하면서 결정하는 것을 아키텍처 설계라 한다.

따라서 아키텍처를 보면 그 시스템이 어떤 용도로 사용되고 무엇을 목적으로 하고 있는지 추측할 수 있으며, 이러한 맥락에서 엔지니어는 반드시 아키텍처나 설계서를 참고해야 하며 시스템에 요구되는 조건을 충족하기 위한 아키텍처를 고민하지 않고 시스템 구축에 필요한 비용을 산출하는 것은 불가능하다.

### 데이터베이스의 아키텍처 1. 역사와 개요

#### Stand-alone의 특징

Stand-alone은 문자 그대로 데이터베이스가 작동하는 기계(Machine)이 근거리 통신망(Local Area Network)이나 인터넷 등의 네트워크에 접속하지 않고 독립되어 작동하는 구성을 의미한다.

이 구성에서는 데이터베이스의 미들웨어와 애플리케이션의 소프트웨어는 같은 데이터베이스 서버에서 작동한다. 따라서 데이터베이스를 사용하고 싶은 사용자는 해당 서버가 설치된 장소까지 물리적으로 도달해야 한다.

#### Stand-alone의 단점

이러한 Stand-alone의 단점은 크게 네 가지가 있다.

먼저 물리적으로 떨어진 장소에서 접근할 수 없다. 네트워크에 연결되어 있지 않다는 것은 데이터베이스를 이용하려면 데이터베이스 서버 앞에까지 가서 이용하는 방법밖에 없다.

다음으로 복수 사용자가 동시에 작업할 수 없다. 네트워크에 연결되어 있지 않다는 것은 다시 말해 동시에 서버를 이용할 수 없다는 것을 의미하기 때문이다.

세 번째로 가용성이 낮다. 결국 서버가 유일하게 한 대밖에 존재하지 않기 때문에 장애가 발생하면 서비스가 정지되기 때문이다. 이때 시스템이 서비스 제공시간에 장애 없이 서비스를 계속 지속할 수 있는 비율이 어느 정도인가를 나타내는 개념을 가용성(Availability)이라 한다. 

마지막으로 확장성이 부족하다. Stand-alone은 성능 문제가 있는데 단순히 성능이 나쁜 것 이상으로 성능이 나쁠 때 개선할 수단이 매우 부족함을 의미한다. 

#### Stand-alone의 장점

구축이 간단해서 소규모 작업이나 테스트를 빨리할 수 있는 것은 물론 보안이 매우 높다는 장점이 있다. 네트워크를 매개로 침입할 수 없기 때문에 사용자가 외부에서 물리적인 시도를 하지 않는 이상 서버가 바이러스에 감염되거나 공격받는 일은 일어나지 않는다.

비슷한 맥락으로 데이터 유출 위험 또한 거의 발생하기 어렵다. 네트워크를 사용할 수 없으므로 직접 특정 매체에 복사하기 위해 물리적으로 이동해야 하기 때문이다.

#### 클라이언트/서버 특징

네트워크에 연결하면 복수 사용자가 물리적으로 떨어진 장소에서 데이터베이스에 접속할 수 있게 된다.

#### 클라이언트/서버의 확장

이 구성은 주로 조직 내에 닫힌 네트워크, 다시 말해 근거리 통신망(LAN)에서 주로 사용되었다. 다시 말해 인터넷 등 외부 네트워크를 통해 데이터베이스 서버에 사용자가 접속하는 일이 없었음을 의미한다. 그 이유는 데이터베이스가 매우 중요한 정보를 많이 축적하고 있는 서버이기 때문에 외부로부터 접속을 허가할 경우 보안상의 위험이 증가하기 때문이다.

#### 클라이언트/서버의 단점

인터넷을 통해 시스템을 이용하는 클라이언트/서버 구성은 크게 두 가지 문제점이 있다. 먼저, 인터넷에서 직접 데이터베이스에 접속하는 것에 대한 보안 위험이 있다. 다음으로 불특정 다수의 사용자가 사용하는 클라이언트에서의 애플리케이션 관리비용이 많이 든다는 점이다.

#### 웹 서버 계층과 애플리케이션 계층

앞선 Stand-alone, 그리고 클라이언트/서버 구조의 단점을 극복하기 위해 클라이언트와 데이터베이스 계층 사이에 '웹 서버 계층'과 '애플리케이션 계층'이 추가되어 Web 3계층 아키텍처로 데이터베이스를 이용하기 시작했다.

웹 서버는 클라이언트로부터 접속 요청, 다시 말해 HTTP 요청을 직접 받아 그 처리를 뒷단의 애플리케이션 계층, 다시 말해 애플리케이션 서버에 넘기고 결과를 클라이언트에 반환한다. 이때 애플리케이션 계층은 비즈니스 로직을 구현한 애플리케이션이 작동하는 계층을 의미하며, 웹 서버로부터 연계된 요청을 처리하고, 필요하면 데이터베이스 계층, 다시 말해 데이터베이스 서버에 접속하여 데이터를 추출하고 가공한 뒤 그 결과를 웹 서버로 반환한다.

이렇게 사용자로부터 직접적인 접속 요청을 받는 역할을 웹 서버 계층에 한정하여 애플리케이션 계층과 데이터베이스 계층의 보안을 높일 수 있다. 동시에 애플리케이션 계층에 비즈니스 로직을 집중해서 애플리케이션 관리 비용을 낮추는 구성이 될 수도 있다.

### 데이터베이스의 아키텍처 2. 가용성과 확장성의 확보

#### 가용성을 높이는 2가지 전략

가용성을 높이는 전략은 크게 심장전략과 신장전략이 있다. 심장전략이란 고품질-소수전략을 의미하며, 시스템을 구성하는 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제해서 가용성을 높이는 소수정예 노선을 의미한다. 반대로 신장전략이란 저품질-다수전략을 의미하며, 시스템을 구성하는 각 컴포넌트의 신뢰성을 계속해서 높이기보다는 '사물은 언젠가 망가진다'란 체념을 전제로 여분을 준비해두는, 일종의 물량작전을 의미한다.

#### 클러스터란

신장전략처럼 동일한 기능의 컴포넌트를 병렬화하는 것을 클러스터링(Clustering)이라고 부른다. 클러스터(Cluster)는 사물이나 사람의 집합을 가리키는 말로, 포도 등의 '송이'란 의미 또한 가지고 있다. 이 의미처럼 시스템 세계에서는 동일한 기능의 컴포넌트를 복수 개 준비한 한 개의 기능을 실현한다는 의미로 사용한다.

또한, 클러스터 구성으로 시스템의 가동률을 높이는 것을 '여유도(Redundancy)를 확보한다' 또는 '다중화'라고 지칭한다. 다중화는 시스템 세계에서 '내구성이 더 높고 견고하다'는 좋읜 의미가 있다. 이때 중요한 건 가동률에는 수확체감의 법칙이 작용한다는 점인데, 수확체감의 법칙이란 서버 대수를 증가하여 가동률을 높일 수록 가동률 증가 비율이 점점 작아지는 것을 의미한다. 비슷한 의미로 한계효용체감의 법칙이 있다.

#### 단일 장애점이란

다중화되어 있지 않아서 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트를 단일 장애점(Single Point of Failure, SPOF)이라 한다. 단일 장애점의 신뢰성은 곧 시스템 전체의 가용성을 결정하기 때문에 중요하다. 따라서 단일 장애점을 없애기 위해 이중화를 하지만 결국 어느 정도의 비용을 토대로 다중화를 할 것인지 예산 제약과 신뢰성의 트레이드 오프 관계가 생기기 마련이다.

#### 신뢰성과 가용성

시스템 세계에는 신뢰성(Reliability)과 가용성(Availability)이란 단어가 있다. 일반적으로 신뢰성은 하드웨어나 소프트웨어가 고장 나는 빈도(고장률) 또는 고장 기간을 나타내는 개념이고, 가용성은 '사용자 입장에서 볼 때 시스템을 어느 정도 사용할 수 있는지'를 나타낸다. 다시 말해 시스템을 구성하는 컴포넌트에 대해 적용하는 것이 신뢰성이고, 시스템 전체에서 사용자 눈높이에 맞춰 생각하는 경우를 가용성이라 한다.

일반적으로 신뢰성이 99%일 경우 매우 신뢰할 만한다고 생각할 수 있으나 실제 시스템 세계에서 가용성 99%는 1%의 시간은 이용 불가능한 상황이 된다는 의미이기 때문에 99%의 가용성은 1년 중 3일 15시간 36분은 서비스 다운이 일어날 수 있다는 의미가 되어 가용성이 상당히 낮다고 할 수 있다.

### DB 서버의 다중화 - 클러스터링

#### DB 서버의 다중화

데이터베이스 서버의 다중화가 중요한 가장 큰 이유는 데이터베이스 서버가 데이터를 보존하는 영속 계층(Persistence Layer)이기 때문이다.

#### DB와 다른 서버의 차이

웹 서버나 애플리케이션 서버의 경우 일시적으로 데이터를 보존하기 때문에 데이터를 유지하는 매체의 신뢰성이나 다중화에 그다지 신경 쓸 필요가 없지만 데이터베이스는 대량의 데이터를 영구적으로 보존해야 하고 그에 따른 성능도 요구되기 때문에 데이터를 보존하는 매체에 필요한 요건이 높다.

데이터베이스 서버의 다중화를 고려할 때 가장 중요한 점 중 하나는 바로 데이터 정합성이다. 데이터는 항상 갱신되기 때문에 다중화를 유지하는 중에 데이터 정합성도 중요하게 의식해야 한다.

#### 가장 기본적인 다중화

가장 기본적인 다중화에는 Active-Active, 그리고 Active-Standby 두 종류가 있다. Active-Active의 경우 클러스터를 구성하는 컴포넌트를 동시에 가동하는 다중화 방식이며 Active-Standby의 경우 클러스터를 구성하는 컴포넌트 중 실제 가동하는 것은 Active, 남은 것은 대기(Standby)하고 있는 다중화 방식이다.

#### Active-Active 구성의 장점

Active-Active 구성은 크게 두 가지 장점이 있다. 한 가지는 시스템 다운 시간이 짧다는 점이며, 다른 하나는 성능이 좋다는 점이다. 데이터베이스 서버 대수가 증가하면 동시에 가동하는 CPU나 메모리도 증가하기 때문에 성능도 향상될 수밖에 없다. 그러나 저장소 자체는 결국 하나의 저장소이기 때문에 저장소가 병목(Bottleneck)이 되어 생각 만큼 성능 향상을 기대하기는 어렵다.

Active-Standby 구성에서는 보통 Standby 상태의 데이터베이스 서버는 사용되지 않다가 Active 데이터베이스 서버에서 장애가 발생했을 때 Standy 데이터베이스 서버를 사용한다. 이 때문에 전환될 때까지 시차가 생기고, 시차 동안 시스템은 서비스를 계속하는 것이 불가능한 상태, 즉 다운 상태가 된다.

참고로 Standby 데이터베이스 서버의 경우 일정 간격으로 Active 데이터베이스 서버가 이상이 없는지 통신을 하게 되는데 이를 하트비트(Heartbeat)라 한다. 이를 통해 Active-Standby 구성에서 장애가 일어났을 때 Standby 데이터베이스 서버는 즉각적으로 Active 데이터베이스 서버에 장애가 발생했음을 인지할 수 있다.

#### Active-Standby 구성의 종류

Active-Standby 구성은 크게 Cold-Standby와 Hot-Standby로 구분된다. Cold-Standby의 경우 평소에는 Standby 데이터베이스가 작동하지 않다가 Active 데이터베이스가 다운된 시점에 작동하는 구성을 의미하며 Hot-Standby의 경우 평소에도 Standby 데이터베이스가 작동하는 구성을 의미한다. 따라서 Hot-Standby 구성의 경우 전환 시간은 짧지만, 그만큼 라이선스 비용이 높게 설정되어 있다.

### DB 서버의 다중화 - 리플리케이션

#### 리플리케이션이란

앞에서 설명한 Active-Active 구성과 Active-Standby 클러스터 구성에서는 서버 부분을 다중화할 수 있지만 젖아소 부분은 여전히 다중화할 수 없다. 따라서 결론적으로 데이터를 다중화할 수 없다는 공통적인 단점이 존재한다. 물론 저장소 또한 내부 컴포넌트가 다중화되어 있지만, 데이터 센터 전체가 지진으로 붕괴하거나 화재가 나면 데이터를 전부 잃게 된다.

이런 상황을 대응하기 위한 클러스터 구성이 복제(Replication)다. 이는 데이터베이스 서버와 저장소 세트를 복수로 준비하는 것을 의미한다. 복제의 경우 데이터베이스 서버와 저장소가 동시에 사용 불능일 때에도 서비스를 계속하는 것이 가능하다는 점이 매우 큰 장점이며, 이 견고함 덕택에 재해대책(Disaster Recover, DR) 또는 재난 복구 계획으로 이용되는 경우도 있다. MySQL의 경우 일찍부터 리플리케이션 기술에 집중해왔는데 재해 대책을 위한 목적보다는 부하 분산을 위해 리플리케이션을 발전시킨 것으로 추측된다.

#### 디스크를 다중화하는 RAID

대부분 하드디스크인 저장소 내부의 컴포넌트를 다중화하는 기술을 RAID(Redundant Array of Independent Disks)라고 한다. RAID에도 몇 가지 종류가 있는데, 기본적으로 클러스터링과 동일하게 단일 장애점을 없애는 것을 목표로 한다. 다시 말해 디스크를 병렬로 나열하여 디스크 한 개가 망가지더라도 데이터를 소실하지 않게 하는 것이다.

#### 리플리케이션에서 주의할 점

리플리케이션에서 주의할 점은 Active 측 저장소의 데이터는 항상 사용자로부터 갱신된다는 것이다. 결국 Standby 측 데이터에도 갱신을 반영하여 최신화하지 않으면, 다시 말해 데이터를 동기화(Sync)하지 않으면 Active 측과의 데이터 정합성을 유지할 수 없다. 쉽게 Standby 측의 데이터가 점점 과거의 것이 되는 것이다.

결국 Standby 측의 갱신 주기를 얼마로 할 것인가와 성능 사이에 트레이드 오프 관게가 생긴다. 데이터 보호의 관점에서는 Stadby 측 데이터베이스 서버에서도 기록이 성공한 것을 확인한 단계에서 Active 측의 갱신도 완료된 것으로 하는 게 좋지만, 확인 처리를 어느 정도 생략하면 성능을 향상할 수 있기 때문이다. 실제로 Oracle 같은 경우 이 동기화 단계를 선택할 수 있다.

### 성능을 추구하기 위한 다중화 - Shared Nothing

#### Shared Disk와 Shared Nothing

복수의 서버가 1대의 디스크를 사용하는 구성을 'Shared Disk'라고 부른다. Shared Disk 타입의 Active-Active 구성은 데이터베이스 서버를 늘려도 무한으로 처리율(Throughput)이 향상되지 않고 어딘가에서 한계점에 도달한다. 이것은 저장소가 공유 자원이라서 쉽게 늘리기 어려운 것은 물론 데이터베이스 서버 대수가 증가할 수록 데이터베이스 서버 간의 정보공유를 위한 오버헤드가 크기 때문이다. 그리고 이 단점을 극복하기 위해 등장한 것이 'Shared Nothing'이다.

Shared Nothing은 문자 그대로 아무것도 공유하지 않는 것을 의미하며 네트워크 이외의 자원을 모두 분리하는 방식이다. 이 아키텍처는 서버와 저장소의 세트를 늘리면 병렬처리 때문에 선형적으로 성능이 향상되는 장점이 있다. Google의 경우 자사가 개발한 Shared Nothing 구조를 샤딩(Sharding)이라 부른다.

Shared Nothing 방식은 비용 대비 성능이 좋다. Shared Disk 방식은 복잡한 동기화 구조가 필요해서 구축하려면 복잡하지만, Shared Nothing 방식은 같은 구성의 데이터베이스 서버를 횡으로 나열하기 때문에 구조가 간단하며 원칙적으로 데이터베이스 서버 수에 비례해서 저장소가 늘어난다. 그러나 저장소를 공유하지 않는다는 것은 결국 각각의 데이터베이스 서버가 동일한 1개의 데이터에 접근할 수 없다는 걸 의미한다. 따라서 여러 저장소에 걸친 데이터를 집계해야 할 경우 집계를 위한 정리 서버가 별도로 필요하게 될 뿐더러 독립된 하나의 데이터베이스 서버가 다운될 경우 해당 서버와 연결된 저장소의 데이터에 접근할 수 없게 된다. 결국 이러한 문제에 대처하기 위해 데이터베이스 서버 하나가 다운 되었을 때 다른 데이터베이스 서버가 이를 이어받아 계쏙 처리할 수 있게하는 커버링(Covering) 구성을 고려해야 한다. MySQL의 경우 MySQL Cluster라는 Shared Nothing 타입의 클러스터 구성이 가능한데, 해당 구성에는 커버링이 구성되어 있다.

### 적합한 아키텍처를 설계하기 위해

#### 아키텍처의 정리

가용성, 신뢰성, 재해대책, 성능, 보안 같은 기능적이지 않은 요건에 대해서도 어느 정도 수준으로 요구할 것인지에 따라 선택해야 할 아키텍처 구조가 바뀌게 된다.


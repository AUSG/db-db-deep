> 0903 김유빈 디비디비딥 정리


## 5장 DBMS를 조작할 때 필요한 기본 지식 - 조작하기 전에 알아두어야 할 것

### MySQL 설치

설치 과정은 생략하였습니다.

### MySQL 과 커넥션, 그리고 전화걸기

**커넥션(Connection)**

- 로그인을 통해 프롬프트가 표시된 것 → 사용자와 MySQL이 접속되었다. (연결되었다.)

**커넥션과 전화**

- 커넥션은 로그인에 실패하면 전화의 `잘못된 번호` 와 같은 안내를 받는다.
- 전화와는 달리 1대1이 아닌 복수의 사용자가 동시에 커넥션 할 수 있다.
- 전화를 끊는 것은 로그오프

**세션(Session)**

- 커넥션의 시작과 종료 사이에 DBMS와 다양한 교환을 진행하는데, 그 교환의 시작과 종료까지의 단위
- 기본적으로 커넥션과 섹션은 1:1 대응되어 커넥션 성립 시 암묵적으로 세션이 시작되고, 세션을 끊으면 커넥션도 끊어지는 경우가 많으므로 세션과 커넥션을 잘 구분하지 않는다.

### SQL과 관리명령의 차이

- 데이터베이스를 조작하는 수단은 SQL 외에도 관리 명령이 있다.
- SQL: 관계형 데이터베이스의 데이터를 조작하는 도구
- 관리 명령: SQL 이외 다양한 용도의 명령어
    - DBMS가 정상적으로 동작하는지 감시 또는 DBMS가 이상한 동작을 할 때 문제 해결을 위한 정보수집 등의 용도
    - 관리 명령의 종류나 문법은 DBMS에 따라 다르다.

**관리 명령과 SQL문의 구분방법**

- SQL문은 반드시 SELECT INSERT DELETE UPDATE 중 하나의 단어로 시작한다.
- 이 외의 단어로 시작한다면 관리 명령

### 관계형 데이터베이스의 계층

- **인스턴스 > 데이터베이스 > 스키마 > 오브젝트(테이블, 인덱스, 저장 프로시저 등)**
- **트리 구조**

**인스턴스(Instance)**

- 물리적 개념. DBMS의 동작 단위
- 메모리나 CPU를 사용하는 존재로 OS에 존재하는 **실체**
- OS 입장에서는 **프로세스**라고도 부름
- DBMS에 따라 **서버 프로세스, 서버**라고 부르기도 함
- 인스턴스 아래에 여러 개의 데이터베이스 존재 가능
- 한 개의 OS에서 인스턴스가 복수로 존재 하는 멀티 인스턴스 구성 가능
    - 원칙적으로 (물리 자원이 충분하다면) 가능
    - DBMS는 일반적으로 기동 시에 최저 한계의 메모리 공간을 확보하려고 하기 때문
    - 1대의 인스턴스 내에 여러 데이터베이스를 만들거나, 가상화 환경을 사용하면 되므로 잘 사용하지 않음

**데이터베이스(Database)**

- '데이터베이스'는 데이터를 관리하는 기능의 집합체라는 의미 뿐만 아니라 '계층'을 표시하는 의미도 가짐
- 데이터베이스 아래에 여러 스키마 존재 가능

**스키마(Schema)**

- 스키마를 통해 테이블을 용도별로 나누거나 권한 관리 수행 가능
- 스키마 아래에 여러 테이블 존재 가능

**오브젝트(Object)**

- 최하위 계층
- 테이블(Table), 인덱스(Index), 저장 프로시저(Stored Procedure) 등

**DBMS별 계층 구조**

- 3계층 구조 : 스키마와 데이터베이스의 한 계층을 생략
    - MySQL: 데이터베이스와 스키마를 동일한 것으로 간주 (동의어)
    - Oracle: 4계층 구조로 되어있긴 하지만 인스턴스 아래에 데이터베이스를 한 개만 만들 수 있어 실질적으로 3계층 구조
- 4계층 구조
    - SQL Server, DB2, PostgreSQL
- ANSI 표준으로 정해진 것은 4계층 구조
- 개발사의 의향에 따라 바뀔 수 있음

## 6장 SQL문의 기본 - SELECT문의 이해

### SELECT문의 기본

- SQL은 주로 DBMS에 저장된 테이블을 조작하기 위해 사용
- 데이터베이스가 여러개 존재할 수 있기 때문에 테이블을 보기 위해서는 데이터베이스를 선택해야 함
- 데이터베이스 목록 보기
    
    ```sql
    mysql> show databases;
    ```
    
- 데이터베이스 사용하기
    
    ```sql
    mysql> use 데이터베이스명;
    ```
    
- 테이블 목록 보기
    
    ```sql
    mysql> show tables;
    ```
    

**WHERE**

- 테이블에서 열의 수는 테이블을 작성(정의)했을때 결정되어 이후 명시적으로 변경하지 않는 한 늘어나지 X.
- but 행수는 제한이 X. → SELECT문 줄이고 WHERE을 지정할 것.

```sql
SELECT 컬럼명 FROM 테이블명 WHERE 조건;
```

- 행 수를 제한하기 위해 사용
- 테이블의 각 행을 살피고 일치하는 행만 `SELECT`
- `AND`와 `OR`을 사용해 여러 조건 사용 가능

*연산자 생략

**SQL 기술 규칙**

- SQL문의 마지막에 딜리미터(문장의 단락을 의미하는 기호)를 붙인다. 대부분 세미콜론 (`;`)
- 키워드(SELECT, FROM 등)의 대소문자는 구별하지 않는다. `select`, `SELECTSelect` 모두 가능
- 정수는 기존 그대로 사용, 문자열이나 날짜 시각은 작은 따옴표(`''`)로 감싼다.`1000` 은 정수, `'1000'` 은 문자열
- 단어(word)는 반각 스페이스나 개행으로 구별. 전각 스페이스 사용 X

**DISTINCT와 중복 배제**

- 선택한 행에서 중복을 없애고 싶은 경우 `DISTINCT` 키워드 사용

```sql
SELECT DISTINCT 컬럼명 FROM 테이블명;
```

### SELECT문의 응용 및 조작

- 실행 순서: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY
- 컬럼명
    - `*` 사용 시 모든 컬럼 지정 가능
    - 임의의 열을 `,` 로 구분하여 복수 지정 가능

**검색 결과 정렬 방법**

- 컬럼의 순서는 `SELECT 컬럼1, 컬럼2, ...` 로 지정
- 레코드의 순서는 `ORDER BY` 로 지정

```sql
SELECT ~ ORDER BY 컬럼1 [, 컬럼2, ...] [DESC / ASC]
```

- `DESC/ASC` : 내림차순/오름차순 정렬. 미지정시 오름차순
- 정렬키 : `ORDER BY`에 사용한 열명
    - 정렬키가 Unique하지 않으면 같은 값 내에서 정렬 결과는 매번 다를 수 있음

**집약 함수 (집계 함수)**

- 복수의 행(이나 행의 값)에 대해 집계를 수행하는 함수
- `COUNT` : 테이블의 행수를 알려주는 함수
- `SUM` : 테이블의 수치 데이터를 합계하는 함수
- `AVG` : 테이블의 수치 데이터 평균을 구하는 함수
- `MAX` : 테이블의 임의열 데이터 중 최대값을 구하는 함수
- `MIN` : 테이블의 임의열 데이터 중 최소값을 구하는 함수

**GROUP BY, HAVING**

- 데이터를 몇 개의 그룹으로 나누어 집계 함수를 적용할 수 있음

```sql
SELECT ~ FROM 테이블명 GROUP BY 컬럼1 [, 컬럼2, ...]
```

- HAVING을 통해 집약한 결과에 조건을 적용할 수 있음

```sql
SELECT ~ FROM 테이블명 GROUP BY ~ HAVING 그룹의 값에 대한 조건
```

### 데이터 갱신, 삽입, 제거

데터를 변경하는 **UPDATE문**

```sql
UPDATE 테이블명 SET 열명 = 값 WHERE 조건;
```

- 갱신하는 컬럼에 디폴트값이 있는 경우에는 값 대신 `DEFAULT` 키워드 지정하여 디폴트값으로 갱신 가능

**데이터를 입력하는** **INSERT문**

- INSERT 전에 테이블 정의 확인 필요
    
    ```sql
    SHOW CREATE TABLE 테이블명\G
    ```
    
    - `\G`는 `;` 대신에 사용할 수 있는 딜리미터로 결과를 세로로 보기 쉽게 한다.
    - 테이블 정의 대신 단순 열 정보 조회 가능
        
        ```sql
        DESC 테이블명;
        ```
        
- INSERT문의 기본 구문
    
    ```sql
    INSERT INTO 테이블명(열1[, 열2, ...]) VALUES (값1[, 값2, ...]);
    ```
    
    - 테이블명 뒤의 컬럼 리스트와 `VALUES` 뒤의 값 리스트는 수와 데이터형이 일치하여야 한다.
    - 테이블에 정의된 모든 컬럼에 대해 값 설정 시 컬럼 리스트 생략 가능
    - 디폴트값으로 입력하는 2가지 방법
        - `DEFAULT` 키워드 지정
        - 컬럼 리스트에서 제외하여 암묵적 지정
- MySQL에서는 Multi row insert 가능
    
    ```sql
    INSERT INTO 테이블명(컬럼1, 컬럼2, ...) VALUES (값1-1, 값1-2, ...) [, (값2-1, 값2-2, ...), ...];
    ```
    
    - 보기 쉬움. 처리 시간 단축.
- 자주 사용되는 구문
    
    ```sql
    INSERT INTO 테이블1 SELECT * FROM 테이블2;
    ```
    
    - `SELECT`의 결과를 입력 레코드로 사용

데이터를 제거하는 DELETE 문

```sql
DELETE FROM 테이블명 [WHERE 조건];
```

- 조건 생략 시 테이블의 전체 행이 제거됨
    - 테이블은 남아있음

### 뷰 VIEW

- 뷰는 SQL 시점에서 테이블과 동일하지만 테이블처럼 데이터를 갖는 것이 아닌 테이블에 대한 SELECT를 가지고 있다.
    - 실행 시점에 질의를 재적성하여 수행

뷰를 사용하는 이점

- 복잡한 SELECT 문을 매번 기술할 필요 없음
- 필요한 열과 행만 사용자에게 보여줄 수 있고, 갱신 시에도 뷰 정의에 따른 갱신으로 한정할 수 있다.
- 데이터 저장 없이(기억장치의 용량 사용 없이) 실현 가능
- 뷰를 제거해도 참조 테이블은 영향을 받지 않음

**뷰를 작성하는 CREATE VIEW문**

```sql
CREATE VIEW 뷰 명 (컬럼명1[, 컬럼명2, ...]) AS SELECT 문;
```

**뷰로의 입력, 갱신 제한**

- 어떤 행이 대응하는지 모르거나 어떤 값을 넣으면 좋을지 모르는 경우에는 갱신 불가
    - GROUP BY를 통한 집약 수치, DISTINCT로 얻은 값, 2개 이상의 테이블을 조합한 뷰 등
    - 뷰에서 원래 테이블의 일부 컬럼만 선택되었고, 이외의 컬럼에 DEFAULT 값이 없고 NOT NULL인 경우

**서브쿼리**

- 메인 쿼리와 대비해 서브쿼리를 이용하여 SELECT문의 결과를 데이터처럼 다루거나 수치처럼 취급하여 조건문에 이용 가능한 쿼리
- Scalar 서브쿼리: 한 행, 한 컬럼만 반환하는 서브쿼리

**결합 JOIN**

- `JOIN`을 사용하여 2개 이상의 테이블을 결합하여 쿼리 적용 가능
- `ON` 을 통해 두 테이블의 행을 결합시키기 위해 결합 조건 지정 필요

**INNER JOIN**

- `ON` 으로 지정한 결합 조건에 일치하는 행만을 두 테이블로부터 가져와 결합

```sql
SELECT 선택하고 싶은 열 리스트 FROM 첫 번째 테이블명 INNER JOIN 두 번째 테이블명 ON 결합 조건;
```

**OUTER JOIN**

- 한 쪽 테이블을 기준으로 전체 행을 표시하고 다른 테이블에서는 조건에 일치하는 행만을 가져와 결합

```sql
SELECT 선택하고 싶은 열의 리스트 FROM 첫 번째 테이블명 LEFT OUTER JOIN 두 번째 테이블명 ON 결합 조건;
```

```sql
SELECT 선택하고 싶은 열의 리스트 FROM 첫 번째 테이블명 RIGHT OUTER JOIN 두 번째 테이블명 ON 결합 조건;
```

- 특별한 이유가 없는 한 `LEFT OUTER JOIN` 사용
    - 특별한 이유: 쿼리의 자동 생성으로 첫 번째 테이블, 두 번째 테이블의 순서를 변경할 수 없는 경우 등



## **7장 트랜잭션과 동시성 제어 - 복수의 쿼리 통합**

트랜잭션이란?

- 쿼리를 처리하는 단위. 한 번에 실행되어야 하는 복수의 쿼리를 한 단위로 묶은 것

### 트랜젝션 (ACID 특성)

1. Atomicity(원자성)
    - 트랜잭션이 전부 성공하거나 전부 실패하여야 함
2. Consistency(일관성)
    - 트랜잭션이 성공적으로 실행 완료되면 언제나 일관성 있는 데이터베이스 상태를 유지해야 함
    - 일관성 유지를 위해 데이터베이스 오브젝트에 각종 정합성 제약(유니크 등) 사용 가능
3. Isolation(고립성/격리성)
    - 트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끼어들 수 없어야 함
    - 트랜잭션 밖의 연산이 중간 단계의 데이터를 볼 수 없음
    - 고립성을 위해 Lock과 격리수준을 사용할 수 있음
4. Durability(지속성)
    - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함
    - 모든 트랜잭션은 로그로 남고 시스템 장애 시 발생 전 상태로 되돌릴 수 있어야 함

### MySQL 테이블

**MyISAM형**

- 트랜잭션을 사용할 수 없는 단순한 구조

**InnoDB형**

- 일반적인 DBMS처럼 트랜잭션 구조 사용 가능.
- MVCC(Multi Versioning Concurrency Control) 구조로 동작
- read 수행 시 write 중이어도 Block되지 않음 (read와 read도 서로 Block되지 않음)
    - read 내용은 격리 수준에 따라 내용이 바뀔 수 있음
- write 시 배타적 Lock을 얻음
    - 기본적으로 행 단위로 Lock되며 트랜잭션 종료까지 유지됨
    - 격리 수준이나 InnoDB 설정에 따라 실제 Lock되는 행의 범위가 다를 수 있음
    - Lock 단위는 테이블 전체, 블록, 행 등이 될 수 있음
- write와 write의 경우 나중에 온 트랜잭션이 Lock을 획득하려고 할 때 Block 됨
    - 일정 시간 사이에 Lock을 획득하지 못하면 Lock Timeout
- write 시 이전의 데이터를 UNDO 로그로 Rollback Segment 영역에 유지
- UNDO 로그의 용도
    - write 트랜잭션 `rollback` 시 write 전으로 되돌리기 위해 이용
    - 복수의 트랜잭션으로부터 격리 수준에 따른 write 데이터 참조에 이용
- 같은 행을 write 할 때마다 UNDO 로그가 작성되어 같은 행에 대한 복수 버전 존재

**ANSI 격리 수준 (Transaction Isolation Level)**

- Read Uncommitted (커밋되지 않은 읽기)
    - 가장 완화된 격리 수준
    - DIRTY READ 발생
    - 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽음
    - MVCC 사용 시 Read가 Block되는 경우가 없으므로 해당 격리 수준을 사용할 필요가 없음
- Read Committed (커밋된 읽기)
    - NON-REPEATABLE READ 발생
    - 트랜잭션 안에서 이전에 읽은 데이터를 다시 읽을 때 이전의 결과와 다를 수 있음
- Repeatable Read (반복 읽기)
    - PHANTOM READ 발생
    - 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는 현상 발생 가능
    - MySQL의 기본 설정
- Serializable (직렬화 가능)
    - 가장 엄격한 격리 수준

**Lock Timeout**

- read와 write는 서로를 block하지 않지만, write와 write에서는 나중에 실행된 write가 lock 대기 상태가 됨
- 언제 lock이 풀릴지 모르므로 다른 한쪽은 lock을 기다릴지, 기다리지 않을지, 어느 정도만 기다릴지 설정 가능
- MySQL에서 `innodb_lock_wait_timeout` 시스템 변수로 조정 가능
    
    ```sql
    -- MySQL에서 기다리지 않는 설정은 없으므로 유효값은 1(초) 이상
    > set innodb_lock_wait_timeout=1;
    ```
    
- Lock Timeout이 발생하는 경우 rollback되는 단위는 2가지
    - 트랜잭션 전체 rollback
    - 해당 쿼리만 rollback (default)
- 트랜잭션 전체 rollback 설정 방법
    - Timeout 이후 명시적으로 `ROLLBACK` 수행
    - `innodb_rollback_on_timeout` 시스템 변수 설정
    

**DeadLock (교착 상태)**

- 두 개 이상의 트랜잭션이 서로의 lock이 끝나기만을 기다리며 결과적으로 아무것도 완료되지 못하는 상태
- 일반적인 DBMS에서는 DeadLock을 검출해 교착 상태를 보고
- MySQL에서는 즉시 인식하고 시스템에 영향이 작은 쪽의 트랜잭션을 전체 rollback
- DeadLock을 완전 방지하는 것은 불가능하므로 DeadLock 발생 시 애플리케이션에서 트랜잭션을 재실행할 수 있어야 함
- 클라이언트에서 rollback된 트랜잭션의 오류, 서버 오류 로그 또는 모니터링 커맨드로 DeadLock 확인 가능

[**DBMS 전반적 대책]**

1. 트랜잭션을 자주 커밋
    - 트랜잭션의 단위가 더 작아지므로 교착 상태의 가능성을 낮춤
2. 정해진 순서로 테이블(및 행)에 엑세스
    - 모든 트랜잭션이 테이블 a를 액세스한 후에 테이블 b를 액세스하도록 함
3. 필요 없는 경우에는 Read Lock 획득(`SELECT ~ FOR UPDATE` 등)의 사용 피하기
4. 쿼리에 의한 Lock 범위를 더 좁히거나 Lock 정도를 더 작게 하기
    - 가능한 행 잠금 사용
    - MySQL의 경우 트랜잭션 격리수준을 Read Committed으로 설정
5. 한 테이블의 여러 행을 복수 커넥션에서 순서 변경 없이 write하면 DeadLock 발생 가능성이 높아짐
    - 여러 커넥션에서 write로 인한 DeadLock이 자주 발생할 경우 테이블 단위의 Lock을 통해 write를 Serialize하면 동시성은 떨어지지만 DeadLock은 피할 수 있음

[**MySQL(InnoDB)의 대책]**

1. 테이블에 적절한 인덱스 추가
    - 인덱스를 사용하지 않는 경우 필요한 행의 Lock이 아닌 스캔한 행 전체에 Lock이 걸린다.
    

**복수 커넥션에서의 트랜잭션**

- DDL에 따른 테이블 작성과 DML에 의한 데이터 저장은 트랜잭션이 커밋되기 전까지는 다른 커넥션에서 보이지 않음
- 하지만 이와 상관없이 다른 커넥션에서 보이는 경우가 있음

**DDL에 따른 암묵적 Commit**

- MySQL이나 Oracle에서는 `CREATE TABLE`과 같은 DDL 실행 시 암묵적 커밋이 발행됨
- 암묵적 커밋으로 인해 한 개의 커넥션에서 실행된 `CREATE TABLE`이 성공하면 이후에 다른 커넥션에서 참조 가능

**Auto Commit 설정**

- 트랜잭션의 개시(`BEGIN TRANSACTION`, `START TRANSACTION`, `SET TRANSACTION` 등)가 명시적으로 지정되지 않았을 때 트랜잭션을 구별하는 2가지 모드
    - Auto Commit: 하나의 SQL문이 하나의 트랜잭션
    - 사용자가 `COMMIT` 또는 `ROLLBACK`을 실행하기까지가 하나의 트랜잭션
- MySQL, PostgreSQL, SQL Server 등에서는 기본 설정이 Auto Commit

### 해서는 안되는 트랜잭션 처리

**Auto Commit**

- MySQL에서 새로운 연결은 모두 default로 Auto Commit(하나의 SQL문이 하나의 트랜잭션)이 설정됨
- command line client 같은 대화형 도구를 사용해 간단한 쿼리 실행과 테스트를 하는 경우에는 편리하지만 애플리케이션의 Lock 실행 시에는 Commit 부하가 너무 높음
- 일정 수 이상의 갱신 처리나 트랜잭션 기능 등은 Auto Commit 대신 적절한 단위와 트랜잭션 격리 수준을 사용하도록 함

**긴 트랜잭션**

- 긴 트랜잭션은 데이터베이스 트랜잭션의 동시성이나 자원의 유효성을 저하시킴
- 갱신을 포함하는 경우 Lock이 장시간 이어지고 Block된 트랜잭션을 Timeout 시킴 → DeadLock 발생 가능
- 대량 처리는 적당한 크기의 트랜잭션으로 나눠 실행하기
    - ex) 신규 테이블에 데이터 로드 시 1만건당 커밋 수행
- 아무것도 하지 않는 트랜잭션 주의
    - 읽기 후 트랜잭션이 열린 상태를 유지한다면, 반복 읽기를 위해 UNDO 로그가 계속 유지됨
- 트랜잭션 중에 대화 처리 넣지 않기
    - 사용자와의 대화 처리는 타임아웃을 설정하지 않는 한 끝없이 사용자를 기다리게 됨 → 전체 효율 저하
    - 대화 처리를 최대한 피하고, 사용하는 경우에는 상한을 정하여 무한정 기다리지 않기
- 시스템의 처리 능력을 파악하고 트랜잭션 수를 제한하기
    - 시스템의 요건이나 하드웨어 성능에 따라 최적의 트랜잭션 수가 달라짐
    - 부하 실험을 수행하여 측정하는 수밖에 없음
    - 커넥션 수 상한을 설정하는 `max_connections` 시스템 변수로 조절
- 트랜잭션 관련 설정 확인
    - 시스템 요건이나 애플리케이션 로직에 맞춰 Auto Commit, 격리 수준 등에 대한 설정 변경하기

### leet code

**[1075. Project Employees I](https://leetcode.com/problems/project-employees-i/)**

```json
# Write your MySQL query statement below
SELECT project_id, ROUND(AVG(experience_years), 2) AS average_years FROM Project p JOIN Employee e
ON p.employee_id = e.employee_id
GROUP BY project_id
```

**[608. Tree Node](https://leetcode.com/problems/tree-node/)**
# 7장

# Transaction

> 복수의 쿼리를 연속적으로 사용해 일관성 있는 형태의 한 단위로 취급하기 위해,
한 덩어리로 쿼리를 처리하는 단위를 ‘트랜잭션’이라 한다.
> 

# ACID 특성

## 1. Atomicity (원자성)

데이터의 변경을 수반하는 일련의 데이터 조작이 전부 성공 or 전부 실패할지를 보증하는 특성.

- 모든 쿼리를 수행하는 과정에 있어 중간에 오류가 생기면, 부분 성공, 부분 실패 이렇게 하지 않고 처음으로 돌아간다. (전부 실패처리, ROLLBACK)
- COMMIT or ROLLBACK

## 2. Consistency (일관성)

일련의 데이터 조작 전후에 그 상태를 유지하는 것을 보증하는 특성.

ex.) 새로운 사용자 등록 시, 해당 사용자의 고유 ID에 unique 속성을 붙이면 추후 다른 사용자가 해당 id를 가질 수 없게 된다.

## 3. Isolation (고립성)

일련의 데이터 조작을 복수 사용자가 동시에 실행해도 ‘각각의 처리가 모순없이 실행되는 것을’ 보증하는 특성

- 모순 없다
== 복수의 트랜잭션이 순서대로 실행되는 경우와 같은 결과를 얻을 수 있는 상태
    
    == 직렬화로 처리되는 상태
    

### 격리 수준 (Transaction Isolation Level)

> 4로 갈수록 엄격, 1로 갈수록 완화
> 
1. 커밋되지 않은 읽기 (Read Uncommitted)
2. 커밋된 읽기 (Read Committed)
3. 반복 읽기 (Repeatable Read)
4. 직렬화 가능 (Serializable)

### 격리 수준 완화에 따라 나타나는 현상 3가지

1. 더티 읽기 (Dirty Read)
    - 어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상.
    - 더렵혀진 데이터 = 어떤 데이터처리가 확정되기 전에 과정 중에 있는 데이터
2. 애매한 읽기 (Fuzzy/NonRepeatable Read)
    - 어떤 트랜잭션이 이전에 읽어 들인 데이터를 다시 읽어 들일 때, 2회 이후의 결과가 1회 때와 다른 현상.
    - 최초 SELECT를 통한 데이터 정보와, 시간이 지난 후 다시 SELECT한 데이터 정보가 다를 때.
3. 팬텀 읽기 (Phantom Read)
    - 어떤 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는 현상.
    - SELECT 시 다른 유저의 데이터 삽입 / 제거로 인해 추후 다시 SELECT했을 경우 데이터 정보가 달라지는 (나타나거나 사라지거나) 경우

| 격리 수준 | Dirty Read | Fuzzy Read | Phantom Read |
| --- | --- | --- | --- |
| 커밋되지 않은 읽기 | o | o | o |
| 커밋된 읽기 | x | o | o |
| 반복 읽기 | x | x | o |
| 직렬화 가능 | x | x | x |

## 4. Durability (지속성)

일련의 데이터 조작을 완료(COMMIT)하고 완료 통지를 사용자가 받는 시점에서,

그 조작이 영구적이 되어 그 결과를 잃지 않는 특성.

→ 시스템 오작동, DB / OS 의 이상 종료 등의 장애도 견딜 수 있는 특성.

- 많은 DBMS에서 DB의 구현에는 수많은 로그들을 통해 언제든지 이상 발생 전의 상태로 복원하는 것으로 지속성을 실현.

## 다른 커넥션에선?

> 기본적으로, DDL에 따른 테이블 작성과 DML에 따른 데이터 저장은 “트랜잭션이 커밋되기 전까지 다른 커넥션에서 보이지 않는다.
> 

But, DBMS에선 여러 기능들을 제공한다.

1. DDL에 따른 암묵적인 커밋
2. 오토커밋 설정
    1. 하나의 SQL 문이 하나의 트랜잭션으로 구분
    2. 사용자가 COMMIT / ROLLBACK을 실행하기까지가 하나의 트랜잭션이 된다.

## 트랜잭션 격리 수준에 따른 외관상 차이

example.

A : 반복 읽기, B : 커밋된 읽기

### MVCC에 따른 MySQL의 특성

1. 읽기를 수행할 경우, 갱신 중이라도 블록 X (읽기 - 읽기도 블록 X)
2. 읽기 내용은 격리 수준에 따라 달라진다.
3. 갱신 시 배타적 잠금을 얻는다. 잠금은 기본적으로 행 단위 잠금이나, 격리 수준이나 InnoDB 설정에 따라 범위 다양
4. 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득코자 할 때 블록. 잠금 타임아웃 까지 대기
5. 갱신하는 경우, 갱신 전의 데이터를 UNDO 로그로 ‘롤백 세그먼트’ 영역에 유지한다.
    - UNDO 로그의 용도
        1. 갱신하는 트랜잭션의 롤백 시 갱신 전으로 되돌려준다.
        2. 복수의 트랜잭션으로부터 격리 수준에 따라 대응하는 갱신 데이터를 참조하는데 이용

### 반복 읽기 (A)

최초 쿼리를 실행한 시점에 커밋된 데이터를 읽는다.

같은 쿼리를 복수 회 실행하면 최초 읽은 내용의 결과 세트를 반환 (값이 변하지 않는다.)

### 커밋된 읽기 (B)

쿼리를 실행한 시점에서 커밋된 데이터를 읽는다.

같은 쿼리를 복수 회 실행하면, 그 사이에 다른 트랜잭션에서 커밋했을 때 그 최신 쿼리 데이터를 읽는다.

### 갱신을 수행하는 트랜잭션 자신 (C)

격리 수준에 상관없이 자신이 수행했던 갱신을 즉시 볼 수 있다.

### 커밋되지 않는 읽기

현재 주류인 MVCC를 이용 시, 읽기가 블록되는 일이 없어 커밋되지 않는 읽기가 필요 없어짐.

## 잠금 타임아웃 (Lock Timeout)

갱신과 갱신이 부딪치는 경우, 나중에 온 갱신이 잠금 대기상태가 되는데, 이 상태동안을 잠금 타임아웃이라고 하며, 잠금을 거는 쪽에서 타임아웃 설정을 할 수 있다.

```sql
set innodb_lock_wait_timeout = 1;
```

### 롤백되는 정도

- MySQL : 잠금 타임아웃이 발생하면 “오류 발생 쿼리들” 기본으로 롤백된다.
- 트랜잭션 전체를 롤백하는 방법
    1. 타임아웃 오류 후 명시적으로 롤백 실행
    2. innodb_rollback_on_timeout 시스템 변수 설정
        - TRUE → 트랜잭션 전체를 롤백 / 디폴트는 FALSE

## 교착 상태 (DeadLock)

트랜잭션 모두가 타임아웃에 걸려 아무리 기다려도 상황이 바뀌지 않는 상태.

### InnoDB의 해결법

자체적인 데드락 감지를 사용하여, 두 트랜잭션 중 데이터 변화가 적은 트랜잭션을 롤백하는 방향으로 해결한다.

### DeadLock 예방법

- DBMS 전반적인 대책
    1. 트랜잭션을 자주 커밋한다. → 트랜잭션은 더 작은 단위가 되어 교착 가능성 저하
    2. 정해진 순서로 테이블에 엑세스하게 한다. (동기화)
    3. 필요 없는 경우 읽기 잠금 획득의 사용을 피한다.
<<<<<<< HEAD
    4. 쿼리에 의한 잠금 범위를 더 좁히거나, 잠금 정도를 더 작은 것으로 한다. (MySQL은 되도록 ‘커밋된 읽기’)
    5. 한 테이블의 복수 행을 복수의 연결에서 순서변경 없이 갱신 시 교착상태가 발생하기 쉽다. 이 땐 갱신을 직렬화하면 동시성을 떨어지지만 교착 상태를 회피할 수 있기 때문에 Trade-Off를 고민해봐야 한다.

## 해서는 안 되는 트랜잭션 처리
1. 오토 커밋 (Auto Commit) <br>
    : 쿼리 단위로 커밋하는 MySQL의 디폴트 옵션인데, 애플리케이션의 잠금을 실행 시 커밋의 부하가 너무 많기 때문에 일정 수 이상의 갱신을 수행하는 처리나 트랜잭션의 기능 등은 적절한 단위와 트랜잭션 격리 수준에서 트랜잭션을 이용해 오토커밋을 지양해야 한다.
2. 긴 트랜잭션 (Long Transaction) <br>
    : 긴 트랜잭션은 데이터베이스 트랜잭션의 동시성이나 자원의 유효성을 저하시킨다. 어찌보면 당연한 결과다, 병렬 처리를 수행해야할 때, 락을 획득한 트랜잭션의 길이가 길다면 블록된 다른 트랜잭션들은 하염없이 기다려야 하기 때문.
3. 아무것도 하지 않는 트랜잭션을 유의<br>
    : 한 번 테이블을 SELECT하고 나서 트랜잭션을 열린 채로 둔다면, 추후 이 테이블의 반복 읽기를 유지하기 위해 UNDO 로그가 계속 남아있어야 하기 때문에 주의해야한다.
4. 트랜잭션 중 대화 처리를 넣는 경우<br>
    : 여기서의 대화 처리란 사용자와의 대화를 뜻한다. 동시에 트랜잭션을 가동시키기 위해선 트랜잭션의 단위가 되도록 작아야 하는데, 사용자와의 대화 처리는 상대적으로 매우 커서 타임아웃이 설정되지 않았을 땐 끝없이 사용자의 처리를 기다릴 수 밖에 없고, 전체적인 시스템 효율을 떨어뜨리게 되므로 주의해야 한다.
5. 처리 능력 이상의 트랜잭션 수<br>
    : 트랜잭션의 실행이 다른 트랜잭션의 잠금 때문에 막힌다면 잠금 타임아웃이나 교착 상태의 확률이 증가하고, 이는 성능 저하로 이어진다. 따라서 커넥션이 잘 작동하는 수나 동시 실행할 수 있는 수의 Maximum을 설정하는 것은 이를 막아주므로 잘 활용하자. (MySQL : max_connections - 데이터베이스 서버의 커넥션 수 상한을 설정할 수 있다.)
=======
    4. 쿼리에 의한 잠금 범위를 더 좁히거나, 잠금 정도를 더 작은 것으로 한다. (MySQL은 되도록 ‘커밋된 읽기’
>>>>>>> e6285b878ea6b36cb95401a82e43af6da2d304af

> 1029 김유빈 디비디비딥 정리

# 1장. DBMS 아키텍처

> 공짜 밥은 존재할까?

## DBMS 아키텍처 개요

1. 쿼리 평가 엔진
   계획을 세우고 실행하는 DBMS의 핵심 기능 담당
2. 버퍼 매니저
   버퍼 (메모리)영역을 관리
3. 디스크 용량 매니저
   어디에 어떻게 데이터 저장할지, 데이터의 읽고 쓰기를 제어
4. 트랜잭션 매니저와 락 매니저
   트랜잭션의 정합성 유지 및 실행. 필요시 데이터에 락을 걸어 다른 요청 대기
5. 리커버리 매니저
   데이터 정기적 백업, 문제시 복구

- 성능의 관점에서 가장 중요한 것은 쿼리 평가 엔진 (혹은 이 엔진이 세우는 실행 계획)
- 버퍼 매니저는 성능과 밀접한 관련을 가짐.
  ** 책에서는 하나의 SQL구문을 도립적으로 실행할 때의 성능을 중심으로 설명. 동시 실행시 발생하는 충돌 X**

## DBMS와 버퍼

DBMS의 버퍼 매니저가 어떤 기능을 수행하는가: 버퍼는 성능에 매우 중요한 영향을 미침.
메모리는 한정 but 데이터베이스가 메모리에 저장하고자 하는 데이터는 매우 많음 → 트레이드 오프 발생 (데이터를 버퍼에 어떠한 식으로 확보할 것인가)

### 1. 공짜 밥은 존재할까?

기억 비용: 데이터를 저장하는데 소모되는 비용
![](https://velog.velcdn.com/images/ycoding/post/30c4b92b-7a50-4a8e-b2b1-99d7353c280b/image.jpg)

_기억 비용에 따른 피라미드_

\* 피라미드의 위 아래는 우수한 기억장치를 나누는 기준 아님.

속도 <-> 많은 데이터 저장 사이의 트레이드 오프 발생

### 2. DBMS와 기억장치의 관계

DBMS는 데이터 저장을 목적으로 하는 미들웨어.

하드디스크(HDD)
DBMS가 데이터를 저장하는 매체(저장소)는 현재 대부분 HDD다.(용량, 비용, 성능의 관점)

하드디스크는 기억장치 계층에서 가운데 있는 2차 기억장치로 분류: 2차 기억장치는 그렇게 좋은 장점도 없지만, 그렇게 나쁜 단점도 없는 매체. DB는 대부분의 시스템에서 범용적으로 사용하는 미들웨어이므로, 어떤 상황에서도 평균적인 수치를 가지는 매체를 선택하는 것이 자연스럽다.

but DBMS가 데이터를 디스크 이외에 장소에 저장하지 않는다는 뜻 X. 일반적인 DBMS는 항상 디스크 이외의 장소에도 데이터를 올려놓음. -> (1차 계층의 기억장치 메모리)

**메모리**

메모리는 디스크에 비해 기억비용이 굉장히 비쌈. 따라서 하드웨어 1대에 탑재할 수 있는 양이 크지 않음. 일반적인 DB서버에 경우 탑재되는 메모리의 양은 한두 자리 정도 -> 상용 시스템의 DB 내부 데이터를 모두 메모리에 올리는 것은 불가능.

**버퍼를 활용한 속도 향상**

그렇지만 DBMS가 일부라도 데이터를 메모리에 올리는 것은 성능 향상 때문. 메모리는 가장 빠른 1차 기억장치. 따라서 자주 접근하는 데이터를 메모리 위에 올려둔다면, 같은 SQL 구문을 실행한다고 해도 디스크에서 데이터를 가져올 필요 없이 곧바로 메모리에서 읽어 빠르게 데이터 검색 가능.

디스크 접근을 줄일 수 있다면 굉장히 큰 폭의 성능 향상이 가능하다.

SQL구문의 실행 시간을 대부분 저장소 I/O에 사용하기 때문이다.

**버퍼와 캐시**

이렇게 성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼 또는 캐시라고 부름.

버퍼: 완충제라는 의미인데 사용자와 저장소 사이에서 SQL구문의 디스크 접근을 줄여주는 역할을 함.

캐시: 사용자와 저장소 사이에서 데이터 전송 지연을 완화.

모두 물리적인 매체로 메모리가 사용되는 경우가 많고, 하드디스크 위에 있는 데이터에 접근하는 것보다 훨씬 빠름. 이러한 고속 접근이 가능한 버퍼에 데이터를 어떻게, 어느 정도의 기간동안 올릴지를 관리하는 것이 DBMS의 버퍼 매니저.

### 3. 메모리 위에 있는 두 개의 버퍼

DBMS가 데이터를 유지하기 위해 사용하는 두 종류의 메모리:

- 데이터 캐시
- 로그 버퍼

대부분의 DBMS는 이러한 두 개의 역할을 하는 메모리 영역을 가짐.

**데이터 캐시**

데이터 캐시는 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리영역. 내가 실행한 select 구문에서 선택하고 싶은 데이터가 데이터 캐시에 있다면 디스크와 같은 저속 저장소에 접근하지 않고 처리가 수행되기 때문에 빠르게 응답함

반대로 버퍼에서 데이터를 찾을 수 없다면 저속 저장소까지 데이터를 가지러 가야하기 때문에 SQL구문의 응답속도가 느려짐.

**로그버퍼**

로그 버퍼는 갱신처리(select, delete, update, merge)와 관련이 있음.

DBMS는 갱신과 관련된 SQL 구문을 사용자로부터 받으면, 곧바로 저장소에 있는 데이터를 변경하지 않음. 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 수행.(갱신 처리는 비동기로)

이렇게 데이터베이스의 갱신 처리는 비동기 처리임. -> DBMS가 이러한 시점 차이를 두는 이유는 성능을 높이기 위해서임.
즉 DBMS는 "저장소의 느림을 어떻게 보완한 것인가" 를 계속해서 고민해온 미들웨어.

### 4. 메모리의 성질이 초래하는 트레이드오프

메모리가 가진 단점은 가격이 비싸서 보유할 수 있는 데이터양이 적은 것 뿐만 아니라 몇가지 단점이 더 존재함.

**휘발성**

메모리에는 데이터의 영속성이 없다. 하드웨어의 전원을 꺼버리면 메모리 위에 올라가 있는 데이터가 모두 사라진다. 이러한 성질을 휘발성이라고 한다.

DBMS을 껐다 켜면 버퍼위의 모든 데이터가 사라짐 -> DBMS에 어떤 장애가 발생해서 프로세스다운이 일어나면(= 서버가 죽으면) 메모리 위에 있는 모든 데이터가 날아감.

**휘발성의 위험성**

휘발성의 가장 큰 문제점은 장애가 발생했을 때 메모리에 있는 데이터가 모두 사라져버려 데이터 부정합을 발생시킴.

데이터 캐시라면 장애로 인한 메모리 위의 데이터가 사라져버려도, 원본 데이터는 디스크 위에 남아있으므로 아무 문제가 없음.

하지만 로그 버퍼 위에 존재하는 데이터가 디스크 위의 로그 파일에 반영되기 전 장애가 발생해 사라져 버리면 해당 데이터가 완전히 사라져서 복구조차 불가능. 이는 사용자가 수행했던 갱신 정보가 사라진다는 의미

이러한 문제를 회피하고자 DBMS는 **커밋 시점에 반드시 갱신 정보를 로그파일에 씀으로써, 장애가 발생해도 정합성을 유지**할 수 있게 한다.

커밋(Commit)이란 갱신 처리를 **확정**하는 것으로 DBMS는 커밋된 데이터를 영속화 함. 커밋 때는 반드시 디스크에 동기 접근이 일어남. 여기에서 또다시 트레이드오프가 모습을 드러냄.

디스크에 동기 처리를 한다면 데이터 정합성은 높아지고 성능이 낮아짐. 반대로 성능을 높이러면 데이터의 정합성이 낮아짐.

| 이름        | 데이터 정합성 | 성능 |
| :---------- | :------------ | :--- |
| 동기 처리   | O             | X    |
| 비동기 처리 | X             | O    |

### 5. 시스템 특성에 따른 트레이드 오프

**데이터 캐시와 로그 버퍼의 크기**

DBMS를 보면 데이터 캐시에 비해 로그 버퍼의 초깃값이 굉장히 작음 -> 이렇게 할당한 이유는 DB가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문.

갱신 처리에 값비싼 메모리를 많이 사용하는 것보다는 자주 검색하는 데이터를 캐시에 올려놓는 것이 좋다고 생각하기 때문.

![](https://velog.velcdn.com/images/ycoding/post/266d5931-dc08-406e-903c-d2fdf2048dc5/image.jpg)

_데이터베이스는 검색을 중시한 메모리 배분이 기본._

**검색과 갱신 중에서 중요한 것**
검색과 갱신 중에서 어떤 것이 더 우선되어야 하는가? 트레이드오프 발생.

- 데이터베이스가 어떠한 생각에 기반을 두어 리소스를 배분하고 있는지 이해하는 것이 중요.

로그 버퍼가 큼 - 갱신 처리에 큰 부하
데이터 캐시가 큼 - 검색 처리에 큰 부하

### 6. 추가적인 메모리 영역 '워킹 메모리'

**언제 사용될까?**

DBMS는 메모리 영역을 하나 더 가지고 있는데 정렬 또는 해시 관련 처리에 사용되는 작업용 영역으로 **워킹 메모리(working memory)**라고 함.

정렬은 ORDER BY구, 집합 연산, 윈도우 함수 등의 기능을 사용할 때 실행.
해시는 주로 테이블의 결합에서 해시 결합이 사용되는 때 실행.

_\* 이 메모리 영역의 이름과 관리 방법은 DBMS에 따라 다름_

이 작업용 메모리 영역은 SQL에서 정렬 또는 해시가 필요한 때 사용되고, 종료되면 해제되는 임시영역으로, 일반적으로는 데이터 캐시와 로그 버퍼와는 다른 영역으로 관리되는 경우가 많음.

이 영역이 성능적으로 중요한 이유는 만약 이 영역이 다루려는 데이터양보다 작아 부족해지는 경우 대부분의 DBMS가 저장소를 사용하기 때문. -> OS 동작에서 말하는 스왑과 같은 것.

이러한 시 영역들은 저장소 위에 있으므로 접근 속도가 느림.

**저장소가 부족하면 무슨 일이 일어날까?**

저장소는 메모리에 비해서 굉장히 느리다. 따라서 그런 곳에 접근하게 되면 전체적인 속도가 느려진다.

이 영역은 여러 개의 SQL 구문들이 공유해서 사용하므로, 하나의 SQL 구문을 실행하고 있을 때는 메모리가 잘 들어가지만 여러 개의 SQL 구문을 동시에 실행하면 메모리가 넘치는 경우가 있다. **하나가 있을 때의 성질뿐만 아니라, 여러 개가 있을 때의 성질도 주의해야 한다는 것**이 컨트롤하기 힘든 성능 문제.

DBMS는 메모리가 부족하더라도 무언가를 처리하려고 계속 노력하는 미들웨어라고 생각할 수 있음.

DB는 메모리가 부족하다는 이유로 SQL 구문에 오류를 절대 발생시키지 않음 - DBMS가 중요한 데이터를 보관/처리할 때 운영체제 정도의 급으로 처리 계속성을 담보하려 하기 때문.

## DBMS와 실행 계획

사용사 혹은 개발자가 데이터베이스에서 의식적으로 사용하는 것은 SQL레벨까지. 이후는 SQL구문을 읽어들인 DBMS가 알아서 처리 후 결과 제공. -> 사용자는 데이터가 있는 곳을 알 필요 X. 데이터에 접근하는 방법도 생각하지 X.

- 이는 프로그래밍과는 거리가 멈. SQL은 어디에 있는 데이터를 어떻게 찾고 처리할지 등의 절차적인 세부사항 작성이 필요 X.

### 1. 권한 이양의 죄악

이는 언어의 설계 사상 차이일 뿐, 좋고 나쁨을 구분하는 것이 아님

절차 기초 언어(C, Java등): `HOW`를 책임지고 기술하는 것이 전제.

비 절차적인 RDB: `WHAT`을 기술하는 것. (나머지는 시스템이 처리)

-> 비즈니스 전체의 생산성 향상을 위한 선택.
그러나 반은 맞고 반은 틀림. SQL은 간단한 언어가 아니며, HOW를 의식하지 않기 때문에 성능 문제가 발생함 -> RDB의 내부 절차를 들여다봐야 하는 이유

### 2. 데이터에 접근하는 방법은 어떻게 결정할까?

쿼리 평가 엔진: RDB에서 데이터 접근 절차를 결정하는 모듈.
![](https://velog.velcdn.com/images/ycoding/post/56e0a072-c6d4-45a7-954e-2643fdab4e2b/image.jpg)

_DBMS의 쿼리 처리 흐름_

**파서(parser)**

이름 그대로 파스(구문 분석)하는 것. 사용자의 SQL구문이 항상 구문적으로 올바르다는 보증이 없으므로 검사진행.

- SQL 구문을 정형적인 형식으로 변환. -> DBMS 내부에서 일어나는 후속 처리의 효율화를 위함.

**옵티마이저(optimizer)**

옵티마이저는 최적화라는 의미를 지님. 최적화의 대상은 데이터 접근법(실행 계획). DBMS 두뇌의 핵심.

선택 가능한 많은 실행 계획을 작성 - 이 비용을 연산 - 가장 낮은 비용의 실행 계획을 선택

**카탈로그 매니저**

카탈로그: DBMS의 내부 정보를 모아놓은 테이블들. 테이블 또는 인덱스의 통계 정보 저장.(카탈로그가 통계 정보로 불리기도 함)

**플랜 평가(plan evaluation)**

옵티마이저의 실행 계획을 받아 최적의 실행 결과를 선택하는 것.
이 실행 계획은 DBMS가 실행할 수 있는 코드가 아닌 문자 그대로의 계획서. 성능이 좋지 않은 SQL구문이 있을 때 실행 계획을 읽고, 수정 방안 등을 고려할 수 있음.

하나의 실행계획을 선택하면 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행.

### 3. 옵티마이저와 통계 정보

카탈로그 매니저가 관리하는 통계 정보에 대해서는 데이터베이스 엔지니어가 신경을 써줘야. (만능이 아니기 때문)

카탈로그에 포함된 콩계 정보

- 각 테이블의 레코드 수
- 각 테이블의 필드 수 / 크기
- 필드의 카디널리티(값의 개수)
- 필드값의 히스토그램(어떤 값이 얼마나 분포되어 있는가)
- 필드 내부에 있는 NULL수
- 인덱스 정보

이러한 카탈로그 정보가 테이블 또는 인덱스의 실제와 일치하지 않을 때 문제가 발생. 테이블에서 수행한 내용에 따라 카탈로그 정보가 갱신되지 않을때, 옵티마이저는 오래된 정보를 바탕으로 실행 계획 세움 -> 당연히 잘못된 계획 (Garbage In, Garbage Out)

### 4. 최적의 실행 계획이 작성되게 하려면

SQL성능에 있어 올바른 통계 정보가 모이는 것은 매우 중요. 테이블의 데이터가 많이 바뀌면 카탈로그의 통계 정보도 함께 갱신해야.

데이터를 크게 생신하는 배치 처리가 있을때는 Job Net을 조합하거나, Oracle 처럼 기본 설정에서 정기적으로 통계 정보 생긴 작업이 수행되는 경우도 존재. 혹은 Microsoft SQL Server처럼 생신 처리가 수행되는 시점에 자동으로 통계 정보를 갱신하는 DBMS도 존재.

통계 정보 갱신은 대상 테이블 또는 인덱스의 크기와 수에 따라 몇십 분 ~ 몇 시간이 소요되기도 함 -> 실행 비용이 매우 높은 작업

DBMS가 최적의 플랜은 선택하려면 필요한 조건이므로 갱신 시점을 확실하게 검토해야.

## 실행 계획이 SQL 구문의 성능을 결정

### 1. 실행 계획 확인 방법

SQL 구문의 지연 발생시 제일 먼저 실행 계획을 살펴봐야.
기본적인 SQL구문의 실행 계획

1. 테이블 풀 스캔(Full Scan)의 실행 계획
2. 인덱스 슼매의 실행 계획
3. 간단한 테이블 결합의 실행 게획

### 2. 테이블 풀 스캔의 실행 계획

레코드 전체 검색을 위한 SQL구문의 실행 계획에서 공통적으로 나타나는 부분

1. 조작 대상 객체
2. 객체에 대한 조작의 종류
3. 조작 대상이 되는 레코드 수

**조작 대상 객체**

테이블 이외에 인덱스, 파티션, 스퀀스와 같은 SQL구문으로 조작할 수 있는 객체는 무엇이든 올 수 있음

**객체에 대한 조작의 종류**

실행 계획에서 가장 중요한 부분. Oracle에서 Operation 피드이며, PostgreSQL의 Seq Scan은 순차적인 접근을 의미. 파일을 순차적으로 접근해서 해당 테이블의 데이터 전체를 읽어낸다는 의미. Oracle의 `TABLE ACCESS FULL`은 테이블의 데이터를 전부 읽어들인다는 의미.

**조작 대상이 되는 레코드 수**

두가지 DBMS 모두 Rows라는 항목에 출력됨. 결합 또는 집략이 포함되면 1개의 SQL구문을 실행해도 여러 개의 조작이 수행. 각 조작에서 얼마만틈의 레코드가 처리되는지가 SQL구문 전체의 실행 비용을 파악하는데 중요한 지표가 됨.

이때 숫자는 옵티마이저가 실행 계획을 만들떄 설명했던 카탈로그 매니저로부터 얻은 값임. 통계 정보에서 파악한 숫자이므로 실제 SQL구문을 실행한 시점의 테이블 레코드 수와 차이가 있을 수 있음.

### 3. 인덱스 스캔의 실행 계획

```
SELECT *
	FROM Shops
  WHERE shop_id = '00050';
```

이때 나타나는 변화를 3개로 나누면

**조작 대상이 되는 레코드 수**

두 DBMS모두 Rows가 1로 변경. WHERE 구에서 기본키가 '00050'인 점포를지정했으므로 접근 대상은 반드시 레코드 하나임.

**접근 대상 객체와 조작**

postgreSQL에서는 `Index Scan`, Oracle에서는 `INDEX UNIQUE SCAN`이라는 조작이 발생. 인덱스를 사용해 스캔을 수행한다는 것.

일반적으로 인덱스는 스캔하는 모집합 레코드 수에서 선택되는 레코드 수가 적다면 테이블 풀 스캔보다 빠르게 접근을 수행. -> 풀 스캔이 모집합의 데이터양에 비례해서 처리 비용이 늘어나는 것에 반해 인덱스를 사용할 때 활용되는 B-tree가 모집합의 데이터양에 따라 대수 함수적으로 처리 비용이 늘어나기 떄문.

![](https://velog.velcdn.com/images/ycoding/post/57abc618-69d7-4faa-ad28-ea3290418749/image.jpg)

_모집합의 데이터가 많을수록 인덱스 스캔이 좋음_

### 4. 간단한 테이블 결합의 실행 계획

SQL에서 지연이 일어나는 경우는 대부분 결합과 관련된 것. 따라서 결합 시점의 시행 계획 특성을 공부하는 것은 굉장히 중요한 의미가 있다.

실행 계획을 검색할 대상 SQL은 아래와 같다. 예약이 존재하는 점포를 선택하는 SELECT 구문

```
SELECT shop_name
	FROM Shops S INNER JOIN Reservations R
  ON S.shop_id = R.shop_id;
```

DBMS가 결합시 사용하는 세가지 종류의 알고리즘

1. Nested Loops
   한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식. 절차 지향형 언어에서 이중 반복으로 구현되기 때문에 해당 이름이 붙음

2. Sort Merge
   결합 키로 레코드를 정렬하고 순차적으로 두 개의 테이블을 결합하는 방법. 결합 전 전처릴로 정렬을 수행해야 함. (이때 작업용 메모리로 워킹 메모리를 사용)

3. Hash
   결합 키값을 해시값으로 맵핑하는 방법. 해시 테이블을 만들어야 하므로 작업용 메모리 영역을 필요로 함.

**객체에 대한 조작의 종류**

Oracle에서는 `NESTED LOOP` 라고 나오고, postgreSQL에서도 `Nested Loop` 라고 나오기 때문에 같은 알고리즘을 선택함을 알 수 있음.

\+ 실행 계획을 읽는 방법
실행 계획은 일반적으로 트리 구조이고, 중첩 단계가 싶을수록 먼저 실행.

결합 전에 테이블 접근이 먼저 수행되는데, 이때 결합이 어떤 테이블에 먼저 접근하는지가 중요한 의미를 가짐: 같은 중첩 단계에서 위에서 아래로 실행.

## 실행 계획의 중요성

옵티마이저는 우수하지만 완벽하지 않다. 그 이전에 정보를 제대로 주지 못할수도 있다. (ex. 인덱스를 사용해야 빨라지는 데 사용하지 않거나, 테이블 결합 순서를 이상하게 적는 등)

이러한 경우 최후의 튜닝수단을 사용 -> **실행 계획을 수동으로 변경하는 것.**

Oracle이나 MySQL등에서 가지는 힌트 구. 이를 사용하면 SQL 구문에서 옵티마이저에게 강제적으로 명령 가능.

실행 계획을 변경하려면 어떤 선택지가 있는지를 알아야 함

# 프로그래머스 문제 풀이

## 1. 오랜 기간 보호한 동물(2)

[](https://school.programmers.co.kr/learn/courses/30/lessons/59411)

입양을 간 동물 중, 보호 기간이 가장 길었던 동물 두 마리의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 기간이 긴 순으로 조회해야 합니다

ANIMAL_INS 테이블 예시

| ANIMAL_ID | ANIMAL_TYPE | DATETIME            | INTAKE_CONDITION | NAME       | SEX_UPON_INTAKE |
| --------- | ----------- | ------------------- | ---------------- | ---------- | --------------- |
| A354597   | Cat         | 2014-05-02 12:16:00 | Normal           | Ariel      | Spayed Female   |
| A362707   | Dog         | 2016-01-27 12:27:00 | Sick             | Girly Girl | Spayed Female   |
| A370507   | Cat         | 2014-10-27 14:43:00 | Normal           | Emily      | Spayed Female   |
| A414513   | Dog         | 2016-06-07 09:17:00 | Normal           | Rocky      | Neutered Male   |

ANIMAL_OUTS 테이블 예시

| ANIMAL_ID | ANIMAL_TYPE | DATETIME            | NAME       | SEX_UPON_OUTCOME |
| --------- | ----------- | ------------------- | ---------- | ---------------- |
| A354597   | Cat         | 2014-06-03 12:30:00 | Ariel      | Spayed Female    |
| A362707   | Dog         | 2017-01-10 10:44:00 | Girly Girl | Spayed Female    |
| A370507   | Cat         | 2015-08-15 09:24:00 | Emily      | Spayed Female    |

SQL문을 실행하면 다음과 같이 나와야 합니다.

| ANIMAL_ID | NAME       |
| --------- | ---------- |
| A362707   | Girly Girl |
| A370507   | Emily      |

※ 입양을 간 동물이 2마리 이상인 경우만 입력으로 주어집니다.

### 풀이

```sql
-- 코드를 입력하세요
SELECT ANIMAL_OUTS.ANIMAL_ID, ANIMAL_OUTS.NAME
FROM ANIMAL_OUTS, ANIMAL_INS
WHERE ANIMAL_OUTS.ANIMAL_ID = ANIMAL_INS.ANIMAL_ID
ORDER BY DATEDIFF(ANIMAL_OUTS.DATETIME, ANIMAL_INS.DATETIME) DESC # DATEDIFF 함수를 이용하여 날짜 차 계산(보호소 나간 날 - 들어온 날), DESC 통해 정렬
LIMIT 2
```

### 다른 풀이

> Ref. [https://devwarriorjungi.tistory.com/entry/프로그래머스-59411-MySQL-Level3-오랜-기간-보호한-동물2](https://devwarriorjungi.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-59411-MySQL-Level3-%EC%98%A4%EB%9E%9C-%EA%B8%B0%EA%B0%84-%EB%B3%B4%ED%98%B8%ED%95%9C-%EB%8F%99%EB%AC%BC2)

```sql
SELECT I.ANIMAL_ID, I.NAME
FROM ANIMAL_INS AS I
RIGHT JOIN ANIMAL_OUTS AS O ON I.ANIMAL_ID = O.ANIMAL_ID
ORDER BY DATEDIFF(O.DATETIME, I.DATETIME) DESC # O.DATETIME - I.DATETIME. ****내림차순 정렬하여 큰 수부터 나열시켜, 보호기간이 긴것부터 나열
LIMIT 2; # LIMIT 2를 이용하여 값을 2개만 표시
```

ANIMAL_INS와 ANIMAL_OUTS 테이블을 RIGHT JOIN하여 ANIMAL_ID가 일치하는 레코드를 가져오고, 만약 ANIMAL_INS 테이블에 해당 ANIMAL_ID가 없는 경우, NULL

| ANIMAL_ID | NAME       |
| --------- | ---------- |
| A354597   | Ariel      |
| A362707   | Girly Girl |
| A370507   | Emily      |
| NULL      | Rocky      |

![스크린샷 2023-10-29 오후 7.44.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2be15c52-7235-41c4-949c-684add48adab/bfbc82d0-1a6d-4deb-a844-03862ea17295/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.44.20.png)

**※ RIGHT JOIN해서 우측 테이블인 ANIMAL_OUTS의 정보만 사용하는데 굳이 왜 JOIN을 하는지?**

그 이유는 DATEDIFF를 통해 같은 아이디를 가진 동물의 보호기간을 구해주기 위해!

또한, ANIMAL_INS 값은 없고 ANIMAL_OUTS에만 값이 있는 영역은 DATEDIFF 값으로 NULL이 나오고

보호기간 내림차순으로 정렬했을 때, 맨 아래에 위치하게 됩니다.

### cf.

같은 데이터(Kaggle의 "Austin Animal Center Shelter Intakes and Outcomes”) 를 사용한 다른 문제

[](https://school.programmers.co.kr/learn/courses/30/lessons/59040)

```sql
-- 코드를 입력하세요
SELECT ANIMAL_TYPE, COUNT(*) AS count
FROM ANIMAL_INS
GROUP BY ANIMAL_TYPE
ORDER BY ANIMAL_TYPE;
```

고양이와 개가 몇 마리인지 조회 - 동물 별로 GROUP BY - Dog 보다 Cat이 앞이므로 오름차순

## 2. 헤비 유저가 소유한 장소

[](https://school.programmers.co.kr/learn/courses/30/lessons/77487)

### 문제

이 서비스에서는 공간을 둘 이상 등록한 사람을 "헤비 유저"라고 부릅니다. 헤비 유저가 등록한 공간의 정보를 아이디 순으로 조회하는 SQL문을 작성해주세요.

예를 들어, `PLACES` 테이블이 다음과 같다면

| ID       | NAME                                            | HOST_ID  |
| -------- | ----------------------------------------------- | -------- |
| 4431977  | BOUTIQUE STAYS - Somerset Terrace, Pet Friendly | 760849   |
| 5194998  | BOUTIQUE STAYS - Elwood Beaches 3, Pet Friendly | 760849   |
| 16045624 | Urban Jungle in the Heart of Melbourne          | 30900122 |
| 17810814 | Stylish Bayside Retreat with a Luscious Garden  | 760849   |
| 22740286 | FREE PARKING - The Velvet Lux in Melbourne CBD  | 30900122 |
| 22868779 | ★ Fresh Fitzroy Pad with City Views! ★          | 21058208 |

- 760849번 유저는 공간을 3개 등록했으므로 이 유저는 헤비유저입니다.
- 30900122번 유저는 공간을 2개 등록했으므로 이 유저는 헤비유저입니다.
- 21058208번 유저는 공간을 1개 등록했으므로 이 유저는 헤비유저가 아닙니다.

따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다.

| ID       | NAME                                            | HOST_ID  |
| -------- | ----------------------------------------------- | -------- |
| 4431977  | BOUTIQUE STAYS - Somerset Terrace, Pet Friendly | 760849   |
| 5194998  | BOUTIQUE STAYS - Elwood Beaches 3, Pet Friendly | 760849   |
| 16045624 | Urban Jungle in the Heart of Melbourne          | 30900122 |
| 17810814 | Stylish Bayside Retreat with a Luscious Garden  | 760849   |
| 22740286 | FREE PARKING - The Velvet Lux in Melbourne CBD  | 30900122 |

### 풀이

```sql
-- 코드를 입력하세요
SELECT ID, NAME, HOST_ID
FROM PLACES
WHERE HOST_ID IN ( # 서브쿼리 - HOST_ID 그룹화하고 그룹의 행 수가 2 이상인 HOST_ID 조회
    SELECT HOST_ID
    FROM PLACES
    GROUP BY HOST_ID
    HAVING COUNT (ID) >= 2)
ORDER BY ID # id기준 오름차순 정렬
```

### 다른 풀이

> Ref. https://wellbell.tistory.com/156

1. 집계함수 COUNT + PARTITION BY

실행계획을 보면 메인 쿼리와 서브 쿼리 둘다 인덱스를 타지 않고 풀스캔을 하고 둘다에서 filesort가 발생한다.

3가지 방법 중 성능이 가장 별로일거라고 생각이 든다.

```sql
SELECT PL.ID, PL.NAME, PL.HOST_ID
FROM
    (
        SELECT * , COUNT(*) OVER (PARTITION BY HOST_ID) AS HOST_COUNT
        FROM PLACES
    ) PL
WHERE PL.HOST_COUNT > 1
ORDER BY PL.ID;
```

2. GROUP BY + IN절

메인 쿼리는 INDEX 스캔을 사용하고 filesort 또한 발생하지 않는다.

IN절은 존재하는 값을 전부 확인한다는 점에서 아래에서 사용한 EXISTS보다 성능이 낮을 것으로 생각이 된다.

```sql
SELECT *
FROM PLACES PL1
WHERE PL1.HOST_ID IN (
                        SELECT HOST_ID
                        FROM PLACES
                        GROUP BY HOST_ID
                        HAVING COUNT(*) > 1
                     )
ORDER BY ID;
```

3. GROUP BY + EXISTS

IN절을 사용했을 때와 다른점은 서브쿼리의 WHERE에 의한 차이이며

EXISTS는 해당 값의 존재 여부만 체크하므로 3가지 중 가장 좋은 성능을 보일 것으로 생각이 된다.

```sql
SELECT *
FROM PLACES PL1
WHERE EXISTS (
                SELECT 1
                FROM PLACES PL2
                WHERE PL1.HOST_ID = PL2.HOST_ID
                GROUP BY HOST_ID
                HAVING COUNT(*) > 1
             )
ORDER BY ID;
```

### Simple IN vs EXISTS

> 2번과 3번 풀이 추가 설명

- IN 절의 괄호() 사이에는 특정 값이나, 서브쿼리가 올 수 있지만, EXISTS의 괄호() 사이에는 서브쿼리만 올 수 있다.
- IN 절에서는 괄호 안에 있는 특정 값이나 서브쿼리의 결과 값이 있는지 체크 (IN 쿼리 → 메인 쿼리)
  - 결국 서브 쿼리 결과를 모두 수행
  - 실제 존재하는 데이터들의 모든 값까지 확인한다는 뜻
- EXISTS는 괄호 안의 서브쿼리로부터 해당 값의 존재 유무만 체크한다. (메인쿼리 → EXISTS 쿼리)
  - 한 건이라도 일치하는 결과가 있으면 더 이상 수행하지 않음
  - 조건에 해당하는 ROW가 존재 유무만 확인하고, 더 이상 수행되지 않는다는 뜻

**NOT IN과 NOT EXISTS의 NULL값에 대한 처리**

NOT EXISTS : NULL 데이터에 대해 **TRUE**를 return.

NOT IN : NULL 데이터에 대해 **FALSE를** return. NULL 처리를 하지 않을 경우 누락이 발생
